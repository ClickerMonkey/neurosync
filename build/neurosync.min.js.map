{"version":3,"sources":["header.js","functions.js","eventize.js","Neuro.js","NeuroDatabase.js","NeuroModel.js","NeuroMap.js","NeuroOperation.js","NeuroRemoveLocal.js","NeuroRemoveNow.js","NeuroRemoveRemote.js","NeuroSaveLocal.js","NeuroSaveNow.js","NeuroSaveRemote.js","Neuro_debug.js","Neuro_rest.js","Neuro_store.js","Neuro_live.js","Neuro_offline.js","footer.js"],"names":["global","undefined","isDefined","x","isFunction","constructor","call","apply","isString","isNumber","isNaN","isDate","Date","isRegExp","RegExp","isArray","Array","isObject","toArray","split","S4","Math","random","toString","substring","uuid","transfer","from","to","prop","swap","a","i","k","t","grab","obj","props","copyValues","grabbed","length","p","copy","copyHidden","c","push","getTime","source","match","charAt","diff","curr","old","comparator","d","isEmpty","equals","b","at","bt","aa","ba","compareNumbers","compare","localeCompare","eventize","target","onListeners","$this","property","events","callback","context","on","this","once","offListeners","listeners","event","eventListeners","splice","deleteProperty","off","$on","$once","triggerListeners","args","clear","max","slice","trigger","e","Neuro","options","database","NeuroDatabase","model","Function","className","prototype","NeuroModel","init","debug","Events","CREATION","Database","Model","models","NeuroMap","rest","store","live","handlePublish","relations","setComparator","setRevision","revision","db","$db","values","keys","indices","NeuroOperation","interrupts","NeuroRemoveLocal","reset","NeuroRemoveNow","NeuroRemoveRemote","NeuroSaveLocal","NeuroSaveNow","NeuroSaveRemote","data","REST","REMOTE_UPDATE","REMOTE_CREATE","REMOTE_REMOVE","REMOTE_LOAD","REMOTE_LOAD_OFFLINE","REMOTE_LOAD_ERROR","REMOTE_LOAD_REMOVE","REMOTE_LOAD_RESUME","LOCAL_LOAD","LOCAL_RESUME_DELETE","LOCAL_RESUME_SAVE","LOCAL_LOAD_SAVED","REALTIME_SAVE","REALTIME_REMOVE","SAVE_VALUES","SAVE_PUBLISH","SAVE_CONFLICT","SAVE_UPDATE_FAIL","SAVE_ERROR","SAVE_OFFLINE","SAVE_RESUME","SAVE_REMOTE","SAVE_DELETED","SAVE_OLD_REVISION","SAVE_LOCAL","SAVE_LOCAL_ERROR","SAVE_LOCAL_DELETED","SAVE_LOCAL_BLOCKED","SAVE_REMOTE_DELETED","SAVE_REMOTE_BLOCKED","REMOVE_PUBLISH","REMOVE_LOCAL","REMOVE_MISSING","REMOVE_ERROR","REMOVE_OFFLINE","REMOVE_RESUME","REMOVE_REMOTE","REMOVE_CANCEL_SAVE","REMOVE_LOCAL_ERROR","REMOVE_LOCAL_BLOCKED","REMOVE_LOCAL_NONE","REMOVE_LOCAL_UNSAVED","REMOVE_REMOTE_BLOCKED","ONLINE","OFFLINE","PUBSUB_CREATED","success","failure","put","key","record","remove","all","onPublish","message","online","window","navigator","onLine","forceOffline","setOnline","setOffline","listenToNetworkStatus","addEventListener","document","body","ononline","onoffline","checkNetworkStatus","pendingRefresh","removeKey","getKey","ks","keySeparator","updated","sort","revisionFunction","comparatorFunction","isSorted","n","putRemoteData","encoded","get","decoded","decode","revisionCompare","$saved","current","$toJSON","conflicts","conflicted","currentValue","savedValue","$local","$addOperation","instantiate","has","destroyLocalModel","$hasChanges","removedValue","cache","loadRemote","refresh","records","$deleted","onModels","mapped","$key","onLoadError","status","method","url","api","getModels","getModel","keyString","op","encode","rawData","save","$pendingSave","$init","$operation","$relations","$reset","def","defaults","fields","defaultValue","$set","value","relation","set","$get","$save","setProperties","setValue","$remove","OperationType","operation","queue","execute","$isSaved","$isSavedLocally","$getChanges","saved","index","removeAt","lastValue","pop","lastKey","size","filter","dest","out","v","reverse","half","ceil","rebuildIndex","partition","left","right","pivot","map","floor","j","qsort","l","next","finished","run","finish","tryNext","insertNext","onSuccess","arguments","onFailure","previousValue","finishRemove","saving","handleData"],"mappings":"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","file":"neurosync.min.js","sourcesContent":["(function(global, undefined)\n{\n","\n\nfunction isDefined(x)\n{\n  return typeof x !== 'undefined';\n}\n\nfunction isFunction(x)\n{\n  return !!(x && x.constructor && x.call && x.apply);\n}\n\nfunction isString(x)\n{\n  return typeof x === 'string';\n}\n\nfunction isNumber(x)\n{\n  return typeof x === 'number' && !isNaN(x);\n}\n\nfunction isDate(x)\n{\n  return x instanceof Date;\n}\n\nfunction isRegExp(x)\n{\n  return x instanceof RegExp;\n}\n\nfunction isArray(x)\n{\n  return x instanceof Array;\n}\n\nfunction isObject(x)\n{\n  return x !== null && typeof x === 'object';\n}\n\nfunction toArray(x, split)\n{\n  return x instanceof Array ? x : x.split( split );\n}\n\nfunction indexOf(arr, x, comparator)\n{\n  var cmp = comparator || equalsStrict;\n\n  for (var i = 0, n = arr.length; i < n; i++)\n  {\n    if ( cmp( arr[i], x ) )\n    {\n      return i;\n    }\n  }\n\n  return false;\n}\n\nfunction S4() \n{\n  return (((1+Math.random())*0x10000)|0).toString(16).substring(1);\n}\n\nfunction uuid() \n{\n    return (S4()+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+S4()+S4());\n}\n\nfunction extend(parent, child, override)\n{\n  child.prototype = parent;\n\n  for (var prop in override)\n  {\n    child.prototype[ prop ] = override[ prop ];\n  }\n}\n\nfunction propsMatch(test, testFields, expected, expectedFields)\n{\n  if ( isString( testFields ) ) // && isString( expectedFields )\n  {\n    return test[ testFields ] === expected[ expectedFields ];\n  }\n  else // if ( isArray( testFields ) && isArray( expectedFields ) )\n  {\n    for (var i = 0; i < testFields.length; i++)\n    {\n      var testProp = testFields[ i ];\n      var expectedProp = expectedFields[ i ];\n\n      if ( test[ testProp ] !== expected[ expectedProp ] )\n      {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction transfer(from, to)\n{\n  for (var prop in from)\n  {\n    to[ prop ] = from[ prop ];\n  }\n\n  return to;\n}\n\nfunction swap(a, i, k)\n{\n  var t = a[ i ];\n  a[ i ] = a[ k ];\n  a[ k ] = t;\n}\n\nfunction grab(obj, props, copyValues)\n{\n  var grabbed = {};\n\n  for (var i = 0; i < props.length; i++) \n  {\n    var p = props[ i ];\n\n    if ( p in obj ) \n    {\n      grabbed[ p ] = copyValues ? copy( obj[ p ] ) : obj[ p ];\n    }\n  }\n\n  return grabbed;\n}\n\nfunction copy(x, copyHidden)\n{\n  if (x === void 0)\n  {\n    return x;\n  }\n  if (isArray(x)) \n  {\n    var c = [];\n\n    for (var i = 0; i < x.length; i++) \n    {\n      c.push( copy(x[i]) );\n    }\n    return x;\n  }\n  if (isFunction(x) || typeof x !== 'object' || x === null)\n  {\n    return x;\n  }\n  if (isDate(x))\n  {\n    return new Date( x.getTime() );\n  }\n  if (isRegExp(x))\n  {\n    return new RegExp( x.source, x.toString().match(/[^\\/]*$/)[0] );\n  }\n\n  var c = {};\n\n  for (var prop in x) \n  {\n    if (copyHidden || prop.charAt(0) !== '$')\n    {\n      c[ prop ] = copy( x[prop] );\n    }\n  }\n\n  return c;\n}\n\nfunction diff(curr, old, props, comparator)\n{\n  var d = {};\n\n  for (var i = 0; i < props.length; i++)\n  {\n    var p = props[ i ];\n\n    if (p in curr && p in old && !comparator( curr[ p ], old[ p ] ) )\n    {\n      d[ p ] = copy( curr[ p ] );\n    }\n  }\n\n  return d;\n}\n\nfunction isEmpty(x)\n{\n  if (x === null || x === void 0 || x === 0) \n  {\n    return true;\n  }\n  if (isArray(x)) \n  {\n    return x.length === 0;\n  }\n  if (isDate(x)) \n  {\n    return x.getTime() === 0 || isNaN( x.getTime() );\n  }\n  if (isObject(x)) \n  {\n    for (var prop in x) \n    {\n      return false;\n    }\n    return true;\n  }\n\n  return false;\n}\n\nfunction equalsStrict(a, b)\n{\n  return a === b;\n}\n\nfunction equals(a, b)\n{\n  if (a === b) return true;\n  if (a === null || b === null) return false;\n  if (a !== a && b !== b) return true; // NaN === NaN\n\n  var at = typeof a;\n  var bt = typeof b;\n  if (at !== bt) return false;\n\n  var aa = isArray(a);\n  var ba = isArray(b);\n  if (aa !== ba) return false;\n\n  if (aa) {\n    if (a.length !== b.length) return false;\n    for (var i = 0; i < a.length; i++) {\n      if (!equals(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if (isDate(a)) {\n    return isDate(b) && equals( a.getTime(), b.getTime() );\n  }\n  if (isRegExp(a)) {\n    return isRegExp(b) && a.toString() === b.toString();\n  }\n\n  if (at === 'object') {\n    for (var p in a) {\n      if (p.charAt(0) !== '$' || !isFunction(a[p])) {\n        if (!(p in b) || !equals(a[p], b[p])) {\n          return false;\n        }\n      }\n    }\n    for (var p in b) {\n      if (p.charAt(0) !== '$' || !isFunction(b[p])) {\n        if (!(p in a)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  return false;\n}\n\nfunction compareNumbers(a, b) \n{\n  return (a === b ? 0 : (a < b ? -1 : 1));\n}\n\nfunction compare(a, b)\n{\n  if (a == b) \n  {\n    return 0;\n  }\n  if (isDate(a)) \n  {\n    a = a.getTime();\n  }\n  if (isDate(b)) \n  {\n    b = b.getTime();\n  }\n  if (isNumber(a) && isNumber(b)) \n  {\n    return compareNumbers(a, b);\n  }\n  if (isArray(a) && isArray(b)) \n  {\n    return compareNumbers(a.length, b.length);\n  }\n  \n  return (a + '').localeCompare(b + '');\n}\n","\n/**\n * Adds functions to the given object (or prototype) so you can listen for any \n * number of events on the given object, optionally once. Listeners can be \n * removed later.\n *\n * The following methods will be added to the given target:\n *\n *     target.on( events, callback, [context] )\n *     target.once( events, callback, [context] )\n *     target.off( events, callback )\n *     target.trigger( event, [argument] )\n *\n * Where... \n * - `events` is a string of space delimited events.\n * - `callback` is a function to invoke when the event is triggered.\n * - `context` is an object that should be the `this` when the callback is \n *   invoked. If no context is given the default value is the object which has \n *   the trigger function that was invoked.\n *\n * @method eventize\n * @for Core\n * @param {Object} target The object to add `on`, `once`, `off`, and `trigger` \n *    functions to.\n */\nfunction eventize(target)\n{\n  /**\n   * **See:** {{#crossLink \"Core/eventize:method\"}}{{/crossLink}}\n   * \n   * @class eventize\n   */\n\n  // Adds a listener to $this\n  var onListeners = function($this, property, events, callback, context)\n  {\n    var events = toArray( events, ' ' );\n    \n    if ( !isDefined( $this[ property ] ) )\n    {\n      $this[ property ] = {};\n    }\n    \n    for (var i = 0; i < events.length; i++)\n    {\n      if ( !isDefined( $this[ property ][ events[i] ] ) )\n      {\n        $this[ property ][ events[i] ] = [];\n      }\n      \n      $this[ property ][ events[i] ].push( [ callback, context || $this ] );\n    }\n  };\n  \n  /**\n   * Listens for every occurrence of the given events and invokes the callback\n   * each time any of them are triggered.\n   * \n   * @method on\n   * @for eventize\n   * @param {String|Array|Object} events\n   * @param {Function} callback\n   * @param {Object} [context]\n   * @chainable\n   */\n  target.on = function(events, callback, context)\n  {\n    onListeners( this, '$on', events, callback, context );\n\n    return this;\n  };\n  \n  /**\n   * Listens for the next occurrence for each of the given events and invokes\n   * the callback when any of the events are triggered.\n   * \n   * @method once\n   * @for eventize\n   * @param {String|Array|Object} events\n   * @param {Function} callback\n   * @param {Object} [context]\n   * @chainable\n   */\n  target.once = function(events, callback, context)\n  {\n    onListeners( this, '$once', events, callback, context );\n\n    return this;\n  };\n  \n  // Removes a listener from an array of listeners.\n  var offListeners = function(listeners, event, callback)\n  {\n    if (listeners && event in listeners)\n    {\n      var eventListeners = listeners[ event ];\n      \n      for (var k = eventListeners.length - 1; k >= 0; k--)\n      {\n        if (eventListeners[ k ][0] === callback)\n        {\n          eventListeners.splice( k, 1 );\n        }\n      }  \n    }\n  };\n\n  // Deletes a property from the given object if it exists\n  var deleteProperty = function(obj, prop)\n  {\n    if ( obj && prop in obj )\n    {\n      delete obj[ prop ];\n    }\n  };\n  \n  /**\n   * Stops listening for a given callback for a given set of events.\n   *\n   * **Examples:**\n   *\n   *     target.off();           // remove all listeners\n   *     target.off('a b');      // remove all listeners on events a & b\n   *     target.off(['a', 'b']); // remove all listeners on events a & b\n   *     target.off('a', x);     // remove listener x from event a\n   * \n   * @method off\n   * @for eventize\n   * @param {String|Array|Object} [events]\n   * @param {Function} [callback]\n   * @chainable\n   */\n  target.off = function(events, callback)\n  {\n    // Remove ALL listeners\n    if ( !isDefined( events ) )\n    {\n      deleteProperty( this, '$on' );\n      deleteProperty( this, '$once' );\n    }\n    else\n    {\n      var events = toArray( events, ' ' );\n\n      // Remove listeners for given events\n      if ( !isFunction( callback ) )\n      {\n        for (var i = 0; i < events.length; i++)\n        {\n          deleteProperty( this.$on, events[i] );\n          deleteProperty( this.$once, events[i] );\n        }\n      }\n      // Remove specific listener\n      else\n      {\n        for (var i = 0; i < events.length; i++)\n        {\n          offListeners( this.$on, events[i], callback );\n          offListeners( this.$once, events[i], callback );\n        }\n      }\n    }\n\n    return this;\n  };\n  \n  // Triggers listeneers for the given event\n  var triggerListeners = function(listeners, event, args, clear)\n  {\n    if (listeners && event in listeners)\n    {\n      var eventListeners = listeners[ event ];\n      var max = eventListeners.length;\n     \n      for (var i = 0; i < max; i++)\n      {\n        var callback = eventListeners[ i ];\n        \n        callback[0].apply( callback[1], args );\n      }\n      \n      if ( clear )\n      {\n        if ( eventListeners.length !== max )\n        {\n          listeners[ event ] = eventListeners.slice( max );  \n        }\n        else\n        {\n          delete listeners[ event ];  \n        }\n      }\n    }\n  };\n  \n  /**\n   * Triggers a single event optionally passing an argument to any listeners.\n   * \n   * @method trigger\n   * @for eventize\n   * @param {String} event\n   * @param {Array} args\n   * @chainable\n   */\n  target.trigger = function(events, args)\n  {\n    var events = toArray( events, ' ' );\n\n    for (var i = 0; i < events.length; i++)\n    {\n      var e = events[ i ];\n\n      triggerListeners( this.$on, e, args, false );\n      triggerListeners( this.$once, e, args, true );\n    }\n\n    return this;\n  };\n};","\n/*\nnew Neuro({\n  name: 'name',\n  api: 'http://api/name',\n  pubsub: 'http://url:port',\n  channel: 'houseid',\n  token: 'userid',\n  key: 'id',\n  fields: ['id', 'name', 'updated_at'],\n//  encode: function() {},\n//  decode: function() {}\n});\n*/\n\nfunction Neuro(options)\n{\n  var database = new NeuroDatabase( options );\n\n  var model = new Function('return function ' + options.className + '(props) { this.$init( props ) }')();\n\n  model.prototype = new NeuroModel( database );\n\n  database.model = model;\n  database.init();\n\n  Neuro.debug( Neuro.Events.CREATION, options, database );\n\n  return {\n    Database: database, \n    Model: model\n  };\n}\n\neventize( Neuro );\n","\n\nfunction NeuroDatabase(options)\n{  \n  transfer( options, this );\n\n  this.models = new NeuroMap();\n\n  this.rest = Neuro.rest( this );\n  this.store = Neuro.store( this );\n  this.live = Neuro.live( this, this.handlePublish( this ) );\n\n  this.relations = {};\n\n  this.setComparator( this.comparator );\n  this.setRevision( this.revision );\n}\n\nNeuroDatabase.prototype =\n{\n\n  // Whether or not there's a load pending until we're online again\n  pendingRefresh: false,\n\n  // Removes the key from the given model\n  removeKey: function(model)\n  {\n    var k = this.key;\n\n    if ( isArray(k) )\n    {\n      for (var i = 0; i < k.length; i++) \n      {\n        delete model[ k[i] ];\n      }\n    }\n    else\n    {\n      delete model[ k ];\n    }\n  },\n\n  // Gets the key from the given model\n  getKey: function(model)\n  {\n    var k = this.key;\n    var key = null;\n\n    if ( isArray(k) )\n    {\n      var ks = this.keySeparator || '/';\n      \n      key = '';\n      \n      for (var i = 0; i < k.length; i++) \n      {\n        if (i > 0) \n        {\n          key += ks;\n        }\n\n        key += model[ k[i] ];\n      }\n    }\n    else\n    {\n      key = model[ k ];\n\n      if (!key)\n      {\n        model[ k ] = key = uuid();\n      }\n    }\n\n    return key;\n  },\n\n  // Sorts the models & notifies listeners that the database has been updated.\n  updated: function()\n  {\n    this.sort();\n    this.trigger( 'updated' );\n  },\n\n  // Sets a revision comparision function for this database. It can be a field\n  // name or a function. This is used to avoid updating model data that is older\n  // than the model's current data.\n  setRevision: function(revision)\n  {\n    if ( isFunction( revision ) )\n    {\n      this.revisionFunction = revision;\n    }\n    else if ( isString( revision ) )\n    {\n      this.revisionFunction = function(a, b)\n      {\n        return (revision in a && revision in b) ? (a[ revision ] - b[ revision ]) : false;\n      };\n    }\n    else \n    {\n      this.revisionFunction = function(a, b)\n      {\n        return false;\n      };\n    }\n  },\n\n  // Sets a comparator for this database. It can be a field name, a field name\n  // with a minus in the front to sort in reverse, or a comparator function.\n  setComparator: function(comparator)\n  {\n    if ( isFunction( comparator ) )\n    {\n      this.comparatorFunction = comparator;\n    }\n    else if ( isString( comparator ) )\n    {\n      if ( comparator.charAt(0) === '-' )\n      {\n        comparator = comparator.substring( 1 );\n\n        this.comparatorFunction = function(a, b)\n        {\n          return compare( b[ comparator ], a[ comparator ] );\n        };\n      }\n      else\n      {\n        this.comparatorFunction = function(a, b)\n        {\n          return compare( a[ comparator ], b[ comparator ] );\n        };\n      }\n    }\n    else\n    {\n      this.comparatorFunction = null;\n    }\n  },\n\n  // Sorts the database if it isn't sorted.\n  sort: function()\n  {\n    if ( !this.isSorted() )\n    {\n      this.models.sort( this.comparatorFunction );\n    }\n  },\n\n  // Determines whether this database is sorted.\n  isSorted: function()\n  {\n    var comparator = this.comparatorFunction;\n\n    if ( !comparator )\n    {\n      return true;\n    }\n\n    var models = this.models.values;\n\n    for (var i = 0, n = models.length - 1; i < n; i++)\n    {\n      if ( comparator( models[ i ], models[ i + 1 ] ) > 0 )\n      {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  // Handles when we receive data from the server - either from\n  // a publish, refresh, or values being returned on a save.\n  putRemoteData: function(encoded, key, model)\n  {\n    var db = this;\n    var key = key || db.getKey( encoded );\n    var model = model || db.models.get( key );\n    var decoded = db.decode( copy( encoded ) );\n    var hasModel = !!model;\n\n    if ( model )\n    {\n      var revisionCompare = this.revisionFunction( model, encoded );\n\n      if ( revisionCompare !== false && revisionCompare > 0 )\n      {\n        Neuro.debug( Neuro.Events.SAVE_OLD_REVISION, model, encoded );\n\n        return;\n      }\n    }\n\n    if ( model && model.$saved )\n    {\n      var current = model.$toJSON();\n      var conflicts = {};\n      var conflicted = false;\n      var updated = {};\n\n      for (var prop in encoded)\n      {\n        var currentValue = current[ prop ];\n        var savedValue = model.$saved[ prop ];\n\n        if ( equals( currentValue, savedValue ) )\n        {\n          model[ prop ] = decoded[ prop ];\n          updated[ prop ] = model.$local[ prop ] = encoded[ prop ];\n        }\n        else\n        {\n          conflicts[ prop ] = encoded[ prop ];\n          conflicted = true;\n        }\n\n        model.$saved[ prop ] = copy( encoded[ prop ] );\n      }\n\n      if ( conflicted )\n      {\n        model.trigger( 'partial-update', [encoded, conflicts] );\n      }\n      else\n      {\n        model.trigger( 'full-update', [encoded, updated] );\n      }\n\n      model.trigger( 'remote-update', [encoded] );\n\n      model.$addOperation( NeuroSaveNow );\n    }\n    else\n    {\n      model = db.instantiate( decoded );\n\n      model.$local = encoded;\n      model.$saved = model.$local.$saved = copy( encoded );\n\n      model.$addOperation( NeuroSaveNow );\n    }\n\n    if ( !db.models.has( key ) )\n    {\n      db.models.put( key, model );\n      db.trigger( 'model-added', [model] );\n\n      model.trigger( 'saved' );\n    }\n\n    return model;\n  },\n\n  // Destroys a model locally because it doesn't exist remotely\n  destroyLocalModel: function(key)\n  {\n    var db = this;\n    var model = db.models.get( key );\n\n    if ( model )\n    {\n      // If a model was removed remotely but the model has changes - don't remove it.\n      if ( model.$hasChanges() )\n      {\n        // Removed saved history and the current ID\n        delete model.$saved;\n        delete model.$local.$saved;\n\n        db.removeKey( model );\n        db.removeKey( model.$local );\n\n        model.trigger( 'detach' );\n\n        model.$addOperation( NeuroSaveNow );\n     \n        return false;\n      }\n\n      model.trigger( 'remote-remove' );\n\n      model.$addOperation( NeuroRemoveNow );\n\n      db.models.remove( key );\n      db.trigger( 'model-removed', [model] );\n\n      model.trigger('removed');\n\n      Neuro.debug( Neuro.Events.REMOTE_REMOVE, model );\n    }\n    else\n    {\n      db.store.remove( key, function(removedValue)\n      {\n        if (removedValue) \n        {\n          Neuro.debug( Neuro.Events.REMOTE_REMOVE, removedValue );\n        }\n      });\n\n      // The model didn't exist\n      return false;\n    }\n\n    return true;\n  },\n\n  // Initialize the database by loading local values and on success load\n  // remove values.\n  init: function()\n  {\n    var db = this;\n\n    if ( db.cache === false )\n    {\n      if ( db.loadRemote )\n      {\n        db.refresh();\n      }\n\n      return;\n    }\n\n    db.store.all(function(records, keys)\n    {\n      Neuro.debug( Neuro.Events.LOCAL_LOAD, records );\n\n      db.models.reset();\n\n      for (var i = 0; i < records.length; i++) \n      {\n        var encoded = records[ i ];\n        var key = keys[ i ];\n        var decoded = db.decode( copy( encoded, true ) );\n        var model = db.instantiate( decoded );\n\n        model.$local = encoded;\n\n        if ( encoded.$deleted )\n        {\n          Neuro.debug( Neuro.Events.LOCAL_RESUME_DELETE, model );\n\n          model.$addOperation( NeuroRemoveRemote );\n        }\n        else\n        {\n          if ( !encoded.$saved )\n          {\n            Neuro.debug( Neuro.Events.LOCAL_RESUME_SAVE, model );\n\n            model.$addOperation( NeuroSaveRemote );\n          }\n          else\n          {\n            Neuro.debug( Neuro.Events.LOCAL_LOAD_SAVED, model );\n\n            model.$local.$saved = model.$saved;\n          }\n\n          db.models.put( key, model );\n        }\n      }\n\n      db.trigger( 'local-load' );\n\n      db.updated();\n\n      if ( db.loadRemote !== false )\n      {\n        db.refresh();\n      }\n    });    \n  },\n\n  // Loads all data remotely\n  refresh: function()\n  {\n    var db = this;\n    var options = {\n      method: 'GET',\n      url: db.api\n    };\n\n    db.rest( options, onModels, onLoadError );\n    \n    function onModels(models) \n    {\n      var mapped = {};\n\n      for (var i = 0; i < models.length; i++)\n      {\n        var model = db.putRemoteData( models[ i ] );\n        var key = model.$key();\n\n        mapped[ key ] = model;\n      }\n\n      var keys = db.models.keys;\n\n      for (var i = 0; i < keys.length; i++)\n      {\n        var k = keys[ i ];\n\n        if ( !(k in mapped) )\n        {\n          var old = db.models.get( k );\n\n          if ( old.$saved )\n          {\n            Neuro.debug( Neuro.Events.REMOTE_LOAD_REMOVE, k );\n\n            db.destroyLocalModel( k );\n          }\n        }\n      }\n\n      db.trigger( 'remote-load' );\n\n      db.updated();\n\n      Neuro.debug( Neuro.Events.REMOTE_LOAD, models );\n    }\n\n    function onLoadError(models, status) \n    {\n      if ( status === 0 )\n      {\n        Neuro.checkNetworkStatus();\n\n        if ( !Neuro.online )\n        {\n          db.pendingRefresh = true;\n\n          Neuro.once('online', function()\n          {\n            Neuro.debug( Neuro.Events.REMOTE_LOAD_RESUME );\n\n            if ( db.pendingRefresh )\n            {\n              db.pendingRefresh = false;\n\n              db.refresh(); \n            }\n          })\n        }\n\n        Neuro.debug( Neuro.Events.REMOTE_LOAD_OFFLINE );\n      }\n      else\n      {\n        Neuro.debug( Neuro.Events.REMOTE_LOAD_ERROR, status );\n      }\n    }\n  \n  },\n\n  // The reference to all of the models in the database\n  getModels: function()\n  {\n    return this.models.values;\n  }, \n\n  // Returns a model\n  getModel: function(key)\n  {\n    if ( isArray( key ) )\n    {\n      var ks = this.keySeparator || '/';\n      var keyString = '';\n\n      for (var i = 0; i < key.length; i++)\n      {\n        if (i > 0)\n        {\n          keyString += ks;\n        }\n\n        keyString += key[ i ];\n      }\n\n      key = keyString;\n    }\n\n    return this.models.get( key );\n  },\n\n  // Crates a function for handling real-time changes\n  handlePublish: function(db)\n  {\n    return function(message)\n    {\n      var key = message.key;\n      var encoded = message.model;\n\n      switch (message.op) \n      {\n      case 'SAVE':\n\n        db.putRemoteData( encoded, key );\n        db.updated();\n\n        Neuro.debug( Neuro.Events.REALTIME_SAVE, message.model );\n        break;\n\n      case 'REMOVE':\n\n        if ( db.destroyLocalModel( key ) )\n        {\n          db.updated(); \n        }\n\n        Neuro.debug( Neuro.Events.REALTIME_REMOVE, key );\n        break;\n      }\n    };\n  },\n\n  // Return an instance of the model with the data as initial values\n  instantiate: function(data)\n  {\n    return new this.model( data );\n  },\n\n  // Converts properties in data into their storable form\n  encode: function(data)\n  {\n    return data;\n  },\n\n  // Converts properties in rawData from their storable form to their desired\n  decode: function(rawData)\n  {\n    return rawData;\n  },\n\n  // Save the model\n  save: function(model)\n  {\n    var db = this;\n    var key = model.$key();\n\n    // If the model is deleted, return immediately!\n    if ( model.$deleted )\n    {\n      Neuro.debug( Neuro.Events.SAVE_DELETED, model );\n\n      return;\n    }\n\n    // Place the model and trigger a database update.\n    if ( !db.models.has( key ) )\n    {\n      db.models.put( key, model );\n      db.trigger( 'model-added', [model] );\n      db.updated();\n\n      model.trigger('saved');\n    }\n    else\n    {\n      db.trigger( 'model-updated', [model] );\n    }\n\n    // Start by saving locally.\n    model.$addOperation( NeuroSaveLocal );\n  },\n\n  // Remove the model \n  remove: function(model)\n  {\n    var db = this;\n    var key = model.$key();\n\n    // If we have it in the models, remove it!\n    if ( db.models.has( key ) )\n    {\n      db.models.remove( key );\n      db.trigger( 'model-removed', [model] );\n      db.updated();\n\n      model.trigger('removed');\n    }\n\n    // Mark as deleted right away\n    model.$deleted = true;\n\n    // If we're offline and we have a pending save - cancel the pending save.\n    // TODO Add Debug here?\n    if ( model.$pendingSave )\n    {\n      Neuro.debug( Neuro.Events.REMOVE_CANCEL_SAVE, model );\n\n      model.$pendingSave = false; \n    }\n\n    // Start by removing locally.\n    model.$addOperation( NeuroRemoveLocal );\n  }\n\n};\n\neventize( NeuroDatabase.prototype );","\nfunction NeuroModel(db)\n{\n  this.$db = db;\n\n  /**\n   * @property {NeuroDatabase} $db\n   *           The reference to the database this model is stored in.\n   */\n\n  /**\n   * @property {Object} [$saved]\n   *           An object of encoded data representing the values saved remotely.\n   *           If this object does not exist - the model hasn't been created\n   *           yet.\n   */\n  \n  /**\n   * @property {Boolean} [$deleted]\n   *           A flag placed on a model once it's requested to be deleted. A  \n   *           model with this flag isn't present on any arrays - it's stored\n   *           locally until its successfully removed remotely - then it's \n   *           removed locally.\n   */\n  \n  /**\n   * @property {Object} [$local]\n   *           The object of encoded data that is stored locally. It's $saved\n   *           property is the same object as this $saved property.\n   */\n  \n  /**\n   * @property {Boolean} $pendingSave\n   *           Whether there is a pending save for this model.\n   */\n}\n\nNeuroModel.prototype =\n{\n\n  $init: function(props)\n  {\n    this.$pendingSave = false;\n    this.$operation = null;\n    this.$relations = {};\n\n    this.$reset( props );\n  },\n\n  $reset: function(props)\n  {\n    var def = this.$db.defaults;\n    var fields = this.$db.fields;\n\n    if ( isObject( def ) )\n    {\n      for (var i = 0; i < fields.length; i++)\n      {\n        var prop = fields[ i ];\n\n        if ( prop in def )\n        {\n          var defaultValue = def[ prop ];\n\n          if ( isFunction( defaultValue ) )\n          {\n            this[ prop ] = defaultValue();\n          }\n          else\n          {\n            this[ prop ] = copy( defaultValue );\n          }\n        }\n        else\n        {\n          this[ prop ] = undefined;\n        }\n      }\n    }\n    else\n    {\n      for (var i = 0; i < fields.length; i++)\n      {\n        var prop = fields[ i ];\n\n        this[ prop ] = undefined;\n      }\n    }\n\n    this.$set( props );\n  },\n\n  $set: function(props, value)\n  {\n    if ( isObject( props ) )\n    {\n      transfer( props, this );\n    }\n    else if ( isString( props ) && value !== void 0 )\n    {\n      if ( props in this.$relations )\n      {\n        var relation = this.$db.relations[ props ];\n\n        relation.set( this, value );\n      }\n      else\n      {\n        this[ props ] = value; \n      }\n    }\n  },\n\n  $get: function(props, copyValues)\n  {\n    if ( isArray( props ) )\n    {\n      return grab( this, props, copyValues );\n    }\n    else if ( isObject( props ) )\n    {\n      for (var p in props)\n      {\n        props[ p ] = copyValues ? copy( this[ p ] ) : this[ p ];\n      }\n\n      return props;\n    }\n    else if ( isString( props ) )\n    {\n      if ( props in this.$relations )\n      {\n        var relation = this.$db.relations[ props ];\n        var values = relation.get( this );\n\n        return copyValues ? copy( values ) : values;\n      }\n      else\n      {\n        return copyValues ? copy( this[ props ] ) : this[ props ]; \n      }\n    }\n  },\n\n  $save: function(setProperties, setValue)\n  {\n    this.$set( setProperties, setValue );\n\n    return this.$db.save( this );\n  },\n\n  $remove: function()\n  {\n    return this.$db.remove( this );\n  },\n\n  $addOperation: function(OperationType) \n  {\n    var operation = new OperationType( this );\n\n    if ( !this.$operation ) \n    {\n      this.$operation = operation;\n      this.$operation.execute();\n    } \n    else \n    {\n      this.$operation.queue( operation );\n    }\n  },\n\n  $toJSON: function()\n  {\n    return this.$db.encode( grab( this, this.$db.fields, true ) );\n  },\n\n  $key: function()\n  {\n    return this.$db.getKey( this );\n  },\n\n  $isSaved: function()\n  {\n    return !!this.$saved;\n  },\n\n  $isSavedLocally: function()\n  {\n    return !!this.$local;\n  },\n\n  $getChanges: function()\n  {\n    var saved = this.$saved;\n    var encoded = this.$toJSON();\n    var fields = this.$db.fields;\n\n    return saved ? diff( encoded, saved, fields, equals ) : encoded;\n  },\n\n  $hasChanges: function()\n  {\n    if (!this.$saved) \n    {\n      return true;\n    }\n\n    var encoded = this.$toJSON();\n    var saved = this.$saved;\n\n    for (var prop in encoded) \n    {\n      var currentValue = encoded[ prop ];\n      var savedValue = saved[ prop ];\n\n      if ( !equals( currentValue, savedValue ) ) \n      {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n};\n\neventize( NeuroModel.prototype );","\n/**\n * A NeuroMap has the key-to-value benefits of a map and iteration benefits of an\n * array. This is especially beneficial when most of the time the contents of \n * the structure need to be iterated and order doesn't matter (since removal \n * performs a swap which breaks insertion order).\n *\n * @constructor\n */\nfunction NeuroMap()\n{\n  /**\n   * An array of the values in this map.\n   * @member {Array}\n   */\n  this.values = [];\n\n  /**\n   * An array of the keys in this map.\n   * @type {Array}\n   */\n  this.keys = [];\n\n  /**\n   * An object of key to index mappings.\n   * @type {Object}\n   */\n  this.indices = {};\n}\n\nNeuroMap.prototype =\n{\n\n  /**\n   * Resets the map by initializing the values, keys, and indexes.\n   * \n   * @return {NeuroMap} -\n   *         The reference to this map.\n   */\n  reset: function()\n  {\n    this.values.length = 0;\n    this.keys.length = 0;\n    this.indices = {};\n\n    return this;\n  },\n\n  /**\n   * Puts the value in the map by the given key.\n   *\n   * @param {String} key\n   * @param {V} value\n   * @return {NeuroMap} -\n   *         The reference to this map.\n   */\n  put: function(key, value)\n  {\n    if ( key in this.indices )\n    {\n      this.values[ this.indices[ key ] ] = value;\n    }\n    else\n    {\n      this.indices[ key ] = this.values.length;\n      this.values.push( value );\n      this.keys.push( key );\n    }\n\n    return this;\n  },\n\n  /**\n   * Returns the value mapped by the given key.\n   *\n   * @param {String} key\n   * @return {V}\n   */\n  get: function(key)\n  {\n    return this.values[ this.indices[ key ] ];\n  },\n\n  /**\n   * Removes the value by a given key\n   *\n   * @param {String} key\n   * @return {NeuroMap} -\n   *         The reference to this map.\n   */\n  remove: function(key)\n  {\n    var index = this.indices[ key ];\n\n    if ( isNumber( index ) )\n    {\n      this.removeAt( index );\n    }\n\n    return this;\n  },\n\n  /**\n   * Removes the value & key at the given index.\n   *\n   * @param {Number} index\n   * @return {NeuroMap} -\n   *         The reference to this map.\n   */\n  removeAt: function(index)\n  {\n    var key = this.keys[ index ];\n    var lastValue = this.values.pop();\n    var lastKey = this.keys.pop();\n\n    if ( index < this.values.length )\n    {\n      this.values[ index ] = lastValue;\n      this.keys[ index ] = lastKey;\n      this.indices[ lastKey ] = index;\n    }\n\n    delete this.indices[ key ];\n\n    return this;\n  },\n\n  /**\n   * Returns whether this map has a value for the given key.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n  has: function(key)\n  {\n    return key in this.indices;\n  },\n\n  /**\n   * Returns the number of elements in the map.\n   *\n   * @return {Number}\n   */\n  size: function()\n  {\n    return this.values.length;\n  },\n\n  /**\n   * Passes all values & keys in this map to a callback and if it returns a \n   * truthy value then the key and value are placed in the destination map.\n   * \n   * @param  {Function} callback [description]\n   * @param  {NeuroMap} [dest]     [description]\n   * @return {[type]}            [description]\n   */\n  filter: function(callback, dest)\n  {\n    var out = dest || new NeuroMap();\n    var n = this.size();\n    var values = this.values;\n    var keys = this.keys;\n\n    for (var i = 0; i < n; i++)\n    {\n      var v = values[ i ];\n      var k = keys[ i ];\n\n      if ( callback( v, k ) )\n      {\n        out.put( k, v );\n      }\n    }\n\n    return out;\n  },\n\n  /**\n   * Reverses the order of the underlying values & keys.\n   * \n   * @return {NeuroMap} -\n   *         The referense to this map.\n   */\n  reverse: function()\n  {\n    var max = this.size() - 1;\n    var half = Math.ceil( max / 2 );\n\n    for (var i = 0; i < half; i++)\n    {\n      swap( this.values, i, max - i );\n      swap( this.keys, i, max - i );\n    }\n\n    this.rebuildIndex();\n\n    return this;\n  },\n\n  /**\n   * Sorts the underlying values & keys given a value compare function.\n   * \n   * @param  {function} comparator\n   *         A function which accepts two values and returns a number used for\n   *         sorting. If the first argument is less than the second argument, a\n   *         negative number should be returned. If the arguments are equivalent\n   *         then 0 should be returned, otherwise a positive number should be\n   *         returned.\n   * @return {NeuroMap} -\n   *         The reference to this map.\n   */\n  sort: function(comparator)\n  {\n    var map = this;\n\n    // Sort this partition!\n    function partition(left, right)\n    {\n      var pivot = map.values[ Math.floor((right + left) / 2) ];\n      var i = left;\n      var j = right;\n\n      while (i <= j) \n      {\n        while (comparator( map.values[i], pivot ) < 0) i++\n        while (comparator( map.values[j], pivot ) > 0) j--;\n\n        if (i <= j) {\n          swap( map.values, i, j );\n          swap( map.keys, i, j );\n          i++;\n          j--;\n        }\n      }\n\n      return i;\n    }\n\n    // Quicksort\n    function qsort(left, right)\n    {\n      var index = partition( left, right );\n\n      if (left < index - 1) \n      {\n        qsort( left, index - 1 );\n      }\n\n      if (index < right) \n      {\n        qsort( index, right );\n      }\n    }\n\n    var right = this.size() - 1;\n\n    // Are there elements to sort?\n    if ( right > 0 )\n    {\n      qsort( 0, right );\n\n      this.rebuildIndex();\n    }\n\n    return this;\n  },\n\n  /**\n   * Rebuilds the index based on the keys.\n   * \n   * @return {NeuroMap} -\n   *         The reference to this map.\n   */\n  rebuildIndex: function()\n  {\n    this.indices = {};\n\n    for (var i = 0, l = this.keys.length; i < l; i++)\n    {\n      this.indices[ this.keys[ i ] ] = i;\n    }\n\n    return this;\n  }\n\n};","\nfunction NeuroOperation(interrupts)\n{\n  this.interrupts = interrupts;\n}\n\nNeuroOperation.prototype = \n{\n  reset: function(model)\n  {\n    this.model = model;\n    this.db = model.$db;\n    this.next = null;\n    this.finished = false;\n  },\n\n  queue: function(operation)\n  {\n    if ( this.next && !operation.interrupts )\n    {\n      this.next.queue( operation );\n    }\n    else\n    {\n      this.next = operation;\n    }\n  },\n\n  execute: function()\n  {\n    this.run( this.db, this.model );\n  },\n\n  run: function(db, model)\n  {\n    throw 'NeuroOperation.run Not implemented';\n  },\n\n  finish: function()\n  {\n    if ( !this.finished )\n    {\n      this.finished = true;\n\n      if ( this.model.$operation = this.next )\n      {\n        this.next.execute();\n      }\n    }\n\n    return this;\n  },\n\n  tryNext: function(OperationType)\n  {\n    if ( !this.next )\n    {\n      this.next = new OperationType( this.model );\n    }\n  },\n\n  insertNext: function(OperationType)\n  {\n    var op = new OperationType( this.model );\n\n    op.next = this.next;\n    this.next = op;\n  },\n\n  success: function()\n  {\n    var op = this;\n\n    return function handleSuccess() \n    {\n      op.onSuccess.apply( op, arguments );\n      op.finish();\n    };\n  },\n\n  onSuccess: function()\n  {\n\n  },\n\n  failure: function()\n  {\n    var op = this;\n\n    return function handleFailure() \n    {\n      op.onFailure.apply( op, arguments );\n      op.finish();\n    };\n  },\n\n  onFailure: function()\n  {\n\n  }\n\n};\n\n/**\n\n$operation;\n\n$addOperation: function(OperationType) {\n  var operation = new OperationType( this );\n  if ( !this.$operation ) {\n    this.$operation = operation;\n    this.$operation.execute();\n  } else {\n    this.$operation.queue( operation );\n  }\n}\n\n */","function NeuroRemoveLocal(model)\n{\n  this.reset( model );\n}\n\nNeuroRemoveLocal.prototype = new NeuroOperation( true );\n\nNeuroRemoveLocal.prototype.run = function(db, model)\n{\n  var key = model.$key();\n\n  // If there is no local there's nothing to remove from anywhere!\n  if ( !model.$local )\n  {\n    Neuro.debug( Neuro.Events.REMOVE_LOCAL_NONE, model );\n\n    return this.finish();\n  }\n\n  // If this model hasn't been saved we only need to remove it from local storage.\n  if ( model.$saved )\n  {\n    // Mark local copy as deleted in the event we're not online\n    model.$local.$deleted = true;\n\n    db.store.put( key, model.$local, this.success(), this.failure() );\n  }\n  else\n  {\n    Neuro.debug( Neuro.Events.REMOVE_LOCAL_UNSAVED, model );\n\n    db.store.remove( key, this.success(), this.failure() );\n  }\n};\n\nNeuroRemoveLocal.prototype.onSuccess = function(key, encoded, previousValue)\n{\n  var model = this.model;\n\n  Neuro.debug( Neuro.Events.REMOVE_LOCAL, model );\n\n  if ( model.$saved )\n  {\n    model.$addOperation( NeuroRemoveRemote );\n  }\n};\n\nNeuroRemoveLocal.prototype.onFailure = function(e)\n{\n  var model = this.model;\n\n  Neuro.debug( Neuro.Events.REMOVE_LOCAL_ERROR, model, e );\n\n  if ( model.$saved )\n  {\n    model.$addOperation( NeuroRemoveRemote );\n  }\n};","function NeuroRemoveNow(model)\n{\n  this.reset( model );\n}\n\nNeuroRemoveNow.prototype = new NeuroOperation( true );\n\nNeuroRemoveNow.prototype.run = function(db, model)\n{\n  var key = model.$key();\n\n  if ( db.models.has( key ) )\n  {\n    db.models.remove( key );\n    db.trigger( 'model-removed', [model] );\n    db.updated();\n\n    model.trigger('removed');\n  }\n\n  db.store.remove( key, this.success(), this.failure() );\n};","function NeuroRemoveRemote(model)\n{\n  this.reset( model );\n}\n\nNeuroRemoveRemote.prototype = new NeuroOperation( true );\n\nNeuroRemoveRemote.prototype.run = function(db, model)\n{\n  // Cancel any pending saves\n  model.$pendingSave = false;\n  model.$deleted = true;\n\n  // Grab key & encode to JSON\n  this.key = model.$key();\n\n  // Make the REST call to remove the model\n  var options = {\n    method: 'DELETE',\n    url:    db.api + this.key\n  };\n\n  db.rest( options, this.success(), this.failure() );\n};\n\nNeuroRemoveRemote.prototype.onSuccess = function(data)\n{\n  this.finishRemove();\n};\n\nNeuroRemoveRemote.prototype.onFailure = function(data, status)\n{\n  var key = this.key;\n  var model = this.model;\n\n  if ( status === 404 || status === 410 )\n  {\n    Neuro.debug( Neuro.Events.REMOVE_MISSING, key, model );\n\n    this.finishRemove();\n  }\n  else if ( status !== 0 ) \n  {\n    Neuro.debug( Neuro.Events.REMOVE_ERROR, status, key, model );\n  } \n  else \n  {\n    // Looks like we're offline!\n    Neuro.checkNetworkStatus();\n\n    // If we are offline, wait until we're online again to resume the delete\n    if (!Neuro.online) \n    {\n      Neuro.once('online', function() \n      {\n        Neuro.debug( Neuro.Events.REMOVE_RESUME, model );\n\n        model.$addOperation( NeuroRemoveRemote );\n      });\n    }\n\n    Neuro.debug( Neuro.Events.REMOVE_OFFLINE, model );\n  }\n};\n\nNeuroRemoveRemote.prototype.finishRemove = function()\n{\n  var db = this.db;\n  var key = this.key;\n  var model = this.model;\n\n  Neuro.debug( Neuro.Events.REMOVE_REMOTE, key, model );\n\n  // Remove from local storage now\n  this.insertNext( NeuroRemoveNow );\n\n  // Publish REMOVE\n  Neuro.debug( Neuro.Events.REMOVE_PUBLISH, key, model );\n\n  db.live({\n    op: 'REMOVE',\n    key: key\n  });\n};","function NeuroSaveLocal(model)\n{\n  this.reset( model );\n}\n\nNeuroSaveLocal.prototype = new NeuroOperation( false );\n\nNeuroSaveLocal.prototype.run = function(db, model)\n{\n  // If the model is deleted, return immediately!\n  if ( model.$deleted )\n  {\n    Neuro.debug( Neuro.Events.SAVE_LOCAL_DELETED, model );\n\n    return this.finish();\n  }\n\n  var encoded = model.$toJSON();\n\n  // If this model doesn't have a local copy yet - create it.\n  if ( !model.$local ) \n  {\n    model.$local = encoded;\n  } \n  else \n  {\n    // Copy to the local copy\n    transfer( encoded, model.$local );\n  }\n\n  db.store.put( model.$key(), model.$local, this.success(), this.failure() );\n};\n\nNeuroSaveLocal.prototype.onSuccess = function(key, encoded, previousValue)\n{\n  var model = this.model;\n\n  Neuro.debug( Neuro.Events.SAVE_LOCAL, model );\n\n  this.tryNext( NeuroSaveRemote );\n};\n\nNeuroSaveLocal.prototype.onFailure = function(e)\n{\n  var model = this.model;\n\n  Neuro.debug( Neuro.Events.SAVE_LOCAL_ERROR, model, e );\n\n  this.tryNext( NeuroSaveRemote );\n};","function NeuroSaveNow(model)\n{\n  this.reset( model );\n}\n\nNeuroSaveNow.prototype = new NeuroOperation( false );\n\nNeuroSaveNow.prototype.run = function(db, model)\n{\n  db.store.put( model.$key(), model.$local, this.success(), this.failure() );\n};","function NeuroSaveRemote(model)\n{\n  this.reset( model );\n}\n\nNeuroSaveRemote.prototype = new NeuroOperation( false );\n\nNeuroSaveRemote.prototype.run = function(db, model)\n{\n  // If the model is deleted, return immediately!\n  if ( model.$deleted )\n  {\n    Neuro.debug( Neuro.Events.SAVE_REMOTE_DELETED, model );\n\n    return this.finish();\n  }\n\n  // Grab key & encode to JSON\n  var key = this.key = model.$key();\n\n  // The fields that have changed since last save\n  var saving = this.saving = model.$getChanges();\n\n  // If there's nothing to save, don't bother!\n  if ( isEmpty( saving ) )\n  {\n    return this.finish();\n  }\n\n  // Make the REST call to remove the model\n  var options = {\n    method: model.$saved ? 'PUT' : 'POST',\n    url:    model.$saved ? db.api + key : db.api,\n    data:   saving\n  };\n\n  db.rest( options, this.success(), this.failure() );\n};\n\nNeuroSaveRemote.prototype.onSuccess = function(data)\n{\n  var model = this.model;\n\n  Neuro.debug( Neuro.Events.SAVE_REMOTE, model );\n\n  this.handleData( data );\n};\n\nNeuroSaveRemote.prototype.onFailure = function(data, status)\n{\n  var db = this.db;\n  var model = this.model;\n\n  // A non-zero status means a real problem occurred\n  if ( status === 409 ) // 409 Conflict\n  {\n    Neuro.debug( Neuro.Events.SAVE_CONFLICT, data, model );\n\n    // Update the model with the data saved and returned\n    this.handleData( data, model, this.db );\n  }\n  else if ( status === 410 || status === 404 ) // 410 Gone, 404 Not Found\n  {\n    Neuro.debug( Neuro.Events.SAVE_UPDATE_FAIL, model );\n\n    this.insertNext( NeuroRemoveNow );\n  }\n  else if ( status !== 0 ) \n  {          \n    Neuro.debug( Neuro.Events.SAVE_ERROR, model, status );\n  } \n  else \n  {\n    // Check the network status right now\n    Neuro.checkNetworkStatus();\n\n    // If not online for sure, try saving once online again\n    if (!Neuro.online) \n    {\n      model.$pendingSave = true;\n\n      Neuro.once('online', function() \n      {\n        if ( model.$pendingSave )\n        { \n          model.$pendingSave = false;\n          model.$addOperation( NeuroSaveRemote );\n\n          Neuro.debug( Neuro.Events.SAVE_RESUME, model );\n        }\n      });\n    }\n\n    Neuro.debug( Neuro.Events.SAVE_OFFLINE, model );\n  }\n};\n\nNeuroSaveRemote.prototype.handleData = function(data)\n{\n  var db = this.db;\n  var model = this.model;\n  var saving = this.saving;\n\n  // Check deleted one more time before updating model.\n  if ( model.$deleted )\n  {\n    Neuro.debug( Neuro.Events.SAVE_REMOTE_DELETED, model, data );\n\n    return;\n  }\n\n  // If data was returned, place it in saving to update the model and publish\n  for (var prop in data)\n  {\n    if ( !(prop in saving ) )\n    {\n      saving[ prop ] = data[ prop ];\n    }\n  }\n\n  Neuro.debug( Neuro.Events.SAVE_VALUES, saving, model );\n\n  // If the model hasn't been saved before - create the record where the \n  // local and model point to the same object.\n  if ( !model.$saved )\n  {\n    model.$saved = model.$local.$saved = {};\n  }\n  \n  // Update the model with the return data\n  db.putRemoteData( saving, this.key, model );\n\n  // Publish saved data to everyone else\n  Neuro.debug( Neuro.Events.SAVE_PUBLISH, saving, model );\n\n  db.live({\n    op: 'SAVE',\n    model: saving,\n    key: this.key\n  });\n};","\nNeuro.debug = function(event, data)\n{\n  // up to the user\n};\n\nNeuro.Events = {\n\n  CREATION: 0,                // options, NeuroDatabase\n\n  REST: 1,                    // options\n\n  REMOTE_UPDATE: 2,           // encoded, NeuroModel\n  REMOTE_CREATE: 3,           // encoded, NeuroModel\n  REMOTE_REMOVE: 4,           // NeuroModel\n  REMOTE_LOAD: 5,             // encoded[]\n  REMOTE_LOAD_OFFLINE: 6,     // \n  REMOTE_LOAD_ERROR: 7,       // status\n  REMOTE_LOAD_REMOVE: 8,      // key\n  REMOTE_LOAD_RESUME: 22,     // \n\n  LOCAL_LOAD: 9,              // encoded[]\n  LOCAL_RESUME_DELETE: 10,    // NeuroModel\n  LOCAL_RESUME_SAVE: 11,      // NeuroModel\n  LOCAL_LOAD_SAVED: 12,       // NeuroModel\n\n  REALTIME_SAVE: 13,          // encoded\n  REALTIME_REMOVE: 14,        // key\n\n  SAVE_VALUES: 15,            // encoded, NeuroModel\n  SAVE_PUBLISH: 16,           // encoded, NeuroModel\n  SAVE_CONFLICT: 17,          // encoded, NeuroModel\n  SAVE_UPDATE_FAIL: 18,       // NeuroModel\n  SAVE_ERROR: 19,             // NeuroModel, status\n  SAVE_OFFLINE: 20,           // NeuroModel\n  SAVE_RESUME: 21,            // NeuroModel\n  SAVE_REMOTE: 25,            // NeuroModel\n  SAVE_DELETED: 40,           // NeuroModel\n\n  SAVE_OLD_REVISION: 48,      // NeuroModel, encoded\n\n  SAVE_LOCAL: 23,             // NeuroModel\n  SAVE_LOCAL_ERROR: 24,       // NeuroModel, error\n  SAVE_LOCAL_DELETED: 38,     // NeuroModel\n  SAVE_LOCAL_BLOCKED: 39,     // NeuroModel\n\n  SAVE_REMOTE_DELETED: 41,    // NeuroModel, [encoded]\n  SAVE_REMOTE_BLOCKED: 42,    // NeuroModel\n\n  REMOVE_PUBLISH: 26,         // key, NeuroModel\n  REMOVE_LOCAL: 27,           // key, NeuroModel\n  REMOVE_MISSING: 28,         // key, NeuroModel\n  REMOVE_ERROR: 29,           // status, key, NeuroModel\n  REMOVE_OFFLINE: 30,         // NeuroModel\n  REMOVE_RESUME: 31,          // NeuroModel\n  REMOVE_REMOTE: 32,          // NeuroModel\n  REMOVE_CANCEL_SAVE: 47,     // NeuroModel\n\n  REMOVE_LOCAL: 33,           // NeuroModel\n  REMOVE_LOCAL_ERROR: 34,     // NeuroModel, error\n  REMOVE_LOCAL_BLOCKED: 44,   // NeuroModel\n  REMOVE_LOCAL_NONE: 45,      // NeuroModel\n  REMOVE_LOCAL_UNSAVED: 46,   // NeuroModel\n\n  REMOVE_REMOTE_BLOCKED: 43,  // NeuroModel\n\n  ONLINE: 35,                 //\n  OFFLINE: 36,                //\n\n  PUBSUB_CREATED: 37          // PubSub\n\n};","\n// Neuro.rest = function(options, success(data), failure(data, status))\n\nNeuro.rest = function(database)\n{\n  return function (options, success, failure)\n  {\n    // success ( data )\n    // failure ( data, status )\n    \n    failure( {}, 0 );\n  };\n};","/**\n * A factory function for returning an object capable of storing objects for\n * retrieval later by the application.\n * \n * @param  {NeuroDatabase} database\n *         The database this store is for.\n * @return {Object} -\n *         An object with put, remove, and all functions.\n */\nNeuro.store = function(database)\n{\n  return {\n\n    /**\n     * Places a record in the store with the given key.\n     * \n     * @param  {String|Number} key\n     *         The key to store the record as.\n     * @param  {Object} record\n     *         The record to store.\n     * @param  {function} success\n     *         A function to invoke when the record is successfully stored with\n     *         the key. The arguments of the function should be the key and \n     *         record passed to this function.\n     * @param  {function} failure\n     *         A function to invoke when the record failed to be stored with the\n     *         key. The arguments of the function should be the key, record, and\n     *         an error that occurred if available.\n     */\n    put: function(key, record, success, failure) \n    { \n      // implement\n    },\n\n    /**\n     * Removes a record from the store with the given key.\n     * \n     * @param  {String|Number} key\n     *         The key to remove from the store.\n     * @param  {[type]} success\n     *         A function to invoke when the record doesn't exist in the store.\n     *         The arguments of the function are the removedValue (if any) and\n     *         the key passed to this function.\n     * @param  {[type]} failure\n     *         A function to invoke when there was an issue removing the key\n     *         from the store. The arguments of the function are the key given\n     *         to this function and an error that occurred if available.\n     */\n    remove: function(key, success, failure) \n    {\n      // implement\n    },\n\n    /**\n     * Returns all records and their keys to the given success callback.\n     * \n     * @param  {function} success\n     *         The function to invoke with the array of records and an array\n     *         of keys.\n     * @param  {function} failure\n     *         The function to invoke with the error that occurred if available.\n     */\n    all: function(success, failure) \n    {\n      // implement\n    }\n\n  };\n\n};","\n/**\n * The factory responsible for creating a service which publishes operations\n * and receives operations that have occurred. The first argument is a reference\n * to the NeuroDatabase and the second argument is a function to invoke when a\n * live operation occurs. This function must return a function that can be passed\n * an operation to be delegated to other clients.\n * \n * @param  {NeuroDatabase} database\n *         The database this live function is for.\n * @param  {function} onPublish\n *         The function which receives live operations.\n * @return {function} -\n *         The function which sends operations.\n */\nNeuro.live = function(database, onPublish)\n{\n  return function publish(message)\n  {\n    // ignore the message.\n  };\n};","\n// Initial online\nNeuro.online = window.navigator.onLine !== false;\n\nNeuro.forceOffline = false;\n\n// Set network status to online and notify all listeners\nNeuro.setOnline = function()\n{\n  Neuro.online = true;\n  Neuro.debug( Neuro.Events.ONLINE );\n  Neuro.trigger('online');\n};\n\n// Set network status to offline and notify all listeners\nNeuro.setOffline = function()\n{\n  Neuro.online = false;\n  Neuro.debug( Neuro.Events.OFFLINE );\n  Neuro.trigger('offline');\n};\n\n// This must be called manually - this will try to use built in support for \n// online/offline detection instead of solely using status codes of 0.\nNeuro.listenToNetworkStatus = function()\n{\n  if (window.addEventListener) \n  {\n    window.addEventListener( 'online', Neuro.setOnline, false );\n    window.addEventListener( 'offline', Neuro.setOffline, false );\n  } \n  else \n  {\n    document.body.ononline = Neuro.setOnline;\n    document.body.onoffline = Neuro.setOffline;\n  }\n};\n\n// Check to see if the network status has changed.\nNeuro.checkNetworkStatus = function()\n{\n  var online = window.navigator.onLine;\n\n  if ( Neuro.forceOffline ) \n  {\n    online = false;\n  }\n\n  if (online === true && Neuro.online === false) \n  {\n    Neuro.setOnline();\n  }\n\n  else if (online === false && Neuro.online === true) \n  {\n    Neuro.setOffline();\n  }\n};","\n  global.Neuro = Neuro;\n\n})(window);"],"sourceRoot":"/source/"}