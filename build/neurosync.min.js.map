{"version":3,"sources":["header.js","functions.js","eventize.js","Neuro.js","NeuroDatabase.js","NeuroModel.js","Neuro_debug.js","Neuro_rest.js","Neuro_offline.js","footer.js"],"names":["global","undefined","isDefined","x","isFunction","constructor","call","apply","isString","isNumber","isNaN","isDate","Date","isRegExp","RegExp","isArray","Array","isObject","toArray","split","S4","Math","random","toString","substring","uuid","transfer","from","to","prop","grab","obj","props","copyValues","grabbed","i","length","p","copy","copyHidden","c","push","getTime","source","match","charAt","diff","curr","old","comparator","d","isEmpty","equals","a","b","at","bt","aa","ba","compareNumbers","compare","localeCompare","eventize","target","onListeners","$this","property","events","callback","context","on","this","once","offListeners","listeners","event","eventListeners","k","splice","deleteProperty","off","$on","$once","triggerListeners","argument","clear","max","slice","trigger","e","Neuro","options","database","NeuroDatabase","model","Function","className","prototype","NeuroModel","db","init","debug","Events","CREATION","Database","Model","stork","Stork","models","FastMap","live","handlePublish","$db","$promise","Promise","Done","$pendingSave","$pendingRemove","data","REST","REMOTE_UPDATE","REMOTE_CREATE","REMOTE_REMOVE","REMOTE_LOAD","REMOTE_LOAD_OFFLINE","REMOTE_LOAD_ERROR","REMOTE_LOAD_REMOVE","REMOTE_LOAD_RESUME","LOCAL_LOAD","LOCAL_RESUME_DELETE","LOCAL_RESUME_SAVE","LOCAL_LOAD_SAVED","REALTIME_SAVE","REALTIME_REMOVE","SAVE_VALUES","SAVE_PUBLISH","SAVE_CONFLICT","SAVE_UPDATE_FAIL","SAVE_ERROR","SAVE_OFFLINE","SAVE_RESUME","SAVE_REMOTE","SAVE_DELETED","SAVE_LOCAL","SAVE_LOCAL_ERROR","SAVE_LOCAL_DELETED","SAVE_LOCAL_BLOCKED","SAVE_REMOTE_DELETED","SAVE_REMOTE_BLOCKED","REMOVE_PUBLISH","REMOVE_LOCAL","REMOVE_MISSING","REMOVE_ERROR","REMOVE_OFFLINE","REMOVE_RESUME","REMOVE_REMOTE","REMOVE_CANCEL_SAVE","REMOVE_LOCAL_ERROR","REMOVE_LOCAL_BLOCKED","REMOVE_LOCAL_NONE","REMOVE_LOCAL_UNSAVED","REMOVE_REMOTE_BLOCKED","ONLINE","OFFLINE","PUBSUB_CREATED","rest","promise","$failure","online","window","navigator","onLine","forceOffline","setOnline","setOffline","listenToNetworkStatus","addEventListener","document","body","ononline","onoffline","checkNetworkStatus","$pendingLoad","generateKey","updated","cmp","sort","order","putRemoteData","encoded","key","get","decoded","decode","$saved","current","$toJSON","currentValue","savedValue","$local","$queue","save","instantiate","put","destroyLocalModel","$hasChanges","remove","removedValue","PROMISED","$success","all","records","keys","reset","inst","$deleted","removeRemote","saveRemote","loadRemote","loadPromise","method","url","then","mapped","$key","status","getModels","values","message","op","encode","rawData","waitForPending","args","$pending","either","$reset","interruptPending","$clear","promiseRest","arguments","$saving","fields","finishSave","has","saveLocal","mdoel","localSave","removeModel","$bindTo","removeLocal","localRemove","$set","value","$get","$save","setProperties","setValue","$remove","interrupt","def","defaults","defaultValue","$isSaved","$isSavedLocally","saved"],"mappings":"CAAA,SAAAA,EAAAC,GCEA,QAAAC,GAAAC,GAEA,MAAA,mBAAAA,GAGA,QAAAC,GAAAD,GAEA,SAAAA,GAAAA,EAAAE,aAAAF,EAAAG,MAAAH,EAAAI,OAGA,QAAAC,GAAAL,GAEA,MAAA,gBAAAA,GAGA,QAAAM,GAAAN,GAEA,MAAA,gBAAAA,KAAAO,MAAAP,GAGA,QAAAQ,GAAAR,GAEA,MAAAA,aAAAS,MAGA,QAAAC,GAAAV,GAEA,MAAAA,aAAAW,QAGA,QAAAC,GAAAZ,GAEA,MAAAA,aAAAa,OAGA,QAAAC,GAAAd,GAEA,MAAA,QAAAA,GAAA,gBAAAA,GAGA,QAAAe,GAAAf,EAAAgB,GAEA,MAAAhB,aAAAa,OAAAb,EAAAA,EAAAgB,MAAAA,GAGA,QAAAC,KAEA,OAAA,OAAA,EAAAC,KAAAC,UAAA,GAAAC,SAAA,IAAAC,UAAA,GAGA,QAAAC,KAEA,MAAAL,KAAAA,IAAA,IAAAA,IAAA,IAAAA,IAAA,IAAAA,IAAA,IAAAA,IAAAA,IAAAA,IAGA,QAAAM,GAAAC,EAAAC,GAEA,IAAA,GAAAC,KAAAF,GAEAC,EAAAC,GAAAF,EAAAE,EAGA,OAAAD,GAGA,QAAAE,GAAAC,EAAAC,EAAAC,GAIA,IAAA,GAFAC,MAEAC,EAAA,EAAAA,EAAAH,EAAAI,OAAAD,IACA,CACA,GAAAE,GAAAL,EAAAG,EAEAE,KAAAN,KAEAG,EAAAG,GAAAJ,EAAAK,EAAAP,EAAAM,IAAAN,EAAAM,IAIA,MAAAH,GAGA,QAAAI,GAAAnC,EAAAoC,GAEA,GAAA,SAAApC,EAEA,MAAAA,EAEA,IAAAY,EAAAZ,GACA,CAGA,IAAA,GAFAqC,MAEAL,EAAA,EAAAA,EAAAhC,EAAAiC,OAAAD,IAEAK,EAAAC,KAAAH,EAAAnC,EAAAgC,IAEA,OAAAhC,GAEA,GAAAC,EAAAD,IAAA,gBAAAA,IAAA,OAAAA,EAEA,MAAAA,EAEA,IAAAQ,EAAAR,GAEA,MAAA,IAAAS,MAAAT,EAAAuC,UAEA,IAAA7B,EAAAV,GAEA,MAAA,IAAAW,QAAAX,EAAAwC,OAAAxC,EAAAoB,WAAAqB,MAAA,WAAA,GAGA,IAAAJ,KAEA,KAAA,GAAAX,KAAA1B,IAEAoC,GAAA,MAAAV,EAAAgB,OAAA,MAEAL,EAAAX,GAAAS,EAAAnC,EAAA0B,IAIA,OAAAW,GAGA,QAAAM,GAAAC,EAAAC,EAAAhB,EAAAiB,GAIA,IAAA,GAFAC,MAEAf,EAAA,EAAAA,EAAAH,EAAAI,OAAAD,IACA,CACA,GAAAE,GAAAL,EAAAG,EAEAE,KAAAU,IAAAV,IAAAW,KAAAC,EAAAF,EAAAV,GAAAW,EAAAX,MAEAa,EAAAb,GAAAC,EAAAS,EAAAV,KAIA,MAAAa,GAGA,QAAAC,GAAAhD,GAEA,GAAA,OAAAA,GAAA,SAAAA,GAAA,IAAAA,EAEA,OAAA,CAEA,IAAAY,EAAAZ,GAEA,MAAA,KAAAA,EAAAiC,MAEA,IAAAzB,EAAAR,GAEA,MAAA,KAAAA,EAAAuC,WAAAhC,MAAAP,EAAAuC,UAEA,IAAAzB,EAAAd,GACA,CACA,IAAA,GAAA0B,KAAA1B,GAEA,OAAA,CAEA,QAAA,EAGA,OAAA,EAQA,QAAAiD,GAAAC,EAAAC,GAEA,GAAAD,IAAAC,EAAA,OAAA,CACA,IAAA,OAAAD,GAAA,OAAAC,EAAA,OAAA,CACA,IAAAD,IAAAA,GAAAC,IAAAA,EAAA,OAAA,CAEA,IAAAC,SAAAF,GACAG,QAAAF,EACA,IAAAC,IAAAC,EAAA,OAAA,CAEA,IAAAC,GAAA1C,EAAAsC,GACAK,EAAA3C,EAAAuC,EACA,IAAAG,IAAAC,EAAA,OAAA,CAEA,IAAAD,EAAA,CACA,GAAAJ,EAAAjB,SAAAkB,EAAAlB,OAAA,OAAA,CACA,KAAA,GAAAD,GAAA,EAAAA,EAAAkB,EAAAjB,OAAAD,IACA,IAAAiB,EAAAC,EAAAlB,GAAAmB,EAAAnB,IACA,OAAA,CAGA,QAAA,EAGA,GAAAxB,EAAA0C,GACA,MAAA1C,GAAA2C,IAAAF,EAAAC,EAAAX,UAAAY,EAAAZ,UAEA,IAAA7B,EAAAwC,GACA,MAAAxC,GAAAyC,IAAAD,EAAA9B,aAAA+B,EAAA/B,UAGA,IAAA,WAAAgC,EAAA,CACA,IAAA,GAAAlB,KAAAgB,GACA,KAAA,MAAAhB,EAAAQ,OAAA,IAAAzC,EAAAiD,EAAAhB,KACAA,IAAAiB,IAAAF,EAAAC,EAAAhB,GAAAiB,EAAAjB,KACA,OAAA,CAIA,KAAA,GAAAA,KAAAiB,GACA,KAAA,MAAAjB,EAAAQ,OAAA,IAAAzC,EAAAkD,EAAAjB,KACAA,IAAAgB,IACA,OAAA,CAIA,QAAA,EAGA,OAAA,EAGA,QAAAM,GAAAN,EAAAC,GAEA,MAAAD,KAAAC,EAAA,EAAAA,EAAAD,EAAA,GAAA,EAGA,QAAAO,GAAAP,EAAAC,GAEA,MAAAD,IAAAC,EAEA,GAEA3C,EAAA0C,KAEAA,EAAAA,EAAAX,WAEA/B,EAAA2C,KAEAA,EAAAA,EAAAZ,WAEAjC,EAAA4C,IAAA5C,EAAA6C,GAEAK,EAAAN,EAAAC,GAEAvC,EAAAsC,IAAAtC,EAAAuC,GAEAK,EAAAN,EAAAjB,OAAAkB,EAAAlB,SAGAiB,EAAA,IAAAQ,cAAAP,EAAA,KCrOA,QAAAQ,GAAAC,GASA,GAAAC,GAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAEA,GAAAF,GAAAjD,EAAAiD,EAAA,IAEAjE,GAAA+D,EAAAC,MAEAD,EAAAC,MAGA,KAAA,GAAA/B,GAAA,EAAAA,EAAAgC,EAAA/B,OAAAD,IAEAjC,EAAA+D,EAAAC,GAAAC,EAAAhC,OAEA8B,EAAAC,GAAAC,EAAAhC,QAGA8B,EAAAC,GAAAC,EAAAhC,IAAAM,MAAA2B,EAAAC,GAAAJ,IAeAF,GAAAO,GAAA,SAAAH,EAAAC,EAAAC,GAIA,MAFAL,GAAAO,KAAA,MAAAJ,EAAAC,EAAAC,GAEAE,MAcAR,EAAAS,KAAA,SAAAL,EAAAC,EAAAC,GAIA,MAFAL,GAAAO,KAAA,QAAAJ,EAAAC,EAAAC,GAEAE,KAIA,IAAAE,GAAA,SAAAC,EAAAC,EAAAP,GAEA,GAAAM,GAAAC,IAAAD,GAIA,IAAA,GAFAE,GAAAF,EAAAC,GAEAE,EAAAD,EAAAxC,OAAA,EAAAyC,GAAA,EAAAA,IAEAD,EAAAC,GAAA,KAAAT,GAEAQ,EAAAE,OAAAD,EAAA,IAOAE,EAAA,SAAAhD,EAAAF,GAEAE,GAAAF,IAAAE,UAEAA,GAAAF,GAoBAkC,GAAAiB,IAAA,SAAAb,EAAAC,GAGA,GAAAlE,EAAAiE,GAMA,CACA,GAAAA,GAAAjD,EAAAiD,EAAA,IAGA,IAAA/D,EAAAgE,GAWA,IAAA,GAAAjC,GAAA,EAAAA,EAAAgC,EAAA/B,OAAAD,IAEAsC,EAAAF,KAAAU,IAAAd,EAAAhC,GAAAiC,GACAK,EAAAF,KAAAW,MAAAf,EAAAhC,GAAAiC,OAZA,KAAA,GAAAjC,GAAA,EAAAA,EAAAgC,EAAA/B,OAAAD,IAEA4C,EAAAR,KAAAU,IAAAd,EAAAhC,IACA4C,EAAAR,KAAAW,MAAAf,EAAAhC,QAbA4C,GAAAR,KAAA,OACAQ,EAAAR,KAAA,QA0BA,OAAAA,MAIA,IAAAY,GAAA,SAAAT,EAAAC,EAAAS,EAAAC,GAEA,GAAAX,GAAAC,IAAAD,GACA,CAIA,IAAA,GAHAE,GAAAF,EAAAC,GACAW,EAAAV,EAAAxC,OAEAD,EAAA,EAAAmD,EAAAnD,EAAAA,IACA,CACA,GAAAiC,GAAAQ,EAAAzC,EAEAiC,GAAA,GAAA9D,KAAA8D,EAAA,GAAAgB,GAGAC,IAEAT,EAAAxC,SAAAkD,EAEAZ,EAAAC,GAAAC,EAAAW,MAAAD,SAIAZ,GAAAC,KAeAZ,GAAAyB,QAAA,SAAArB,EAAAiB,GAIA,IAAA,GAFAjB,GAAAjD,EAAAiD,EAAA,KAEAhC,EAAA,EAAAA,EAAAgC,EAAA/B,OAAAD,IACA,CACA,GAAAsD,GAAAtB,EAAAhC,EAEAgD,GAAAZ,KAAAU,IAAAQ,EAAAL,GAAA,GACAD,EAAAZ,KAAAW,MAAAO,EAAAL,GAAA,GAGA,MAAAb,OCzMA,QAAAmB,GAAAC,GAEA,GAAAC,GAAA,GAAAC,GAAAF,GAEAG,EAAA,GAAAC,UAAA,mBAAAJ,EAAAK,UAAA,qCASA,OARAF,GAAAG,UAAA,GAAAC,GAAAN,GACAE,EAAAK,GAAAP,EAEAA,EAAAE,MAAAA,EACAF,EAAAQ,OAEAV,EAAAW,MAAAX,EAAAY,OAAAC,SAAAZ,EAAAC,IAGAY,SAAAZ,EACAa,MAAAX,GC7BA,QAAAD,GAAAF,GAEAjE,EAAAiE,EAAApB,MAEAA,KAAAmC,MAAA,GAAAC,OAAAhB,GACApB,KAAAqC,OAAA,GAAAD,OAAAE,QAEAtC,KAAAuC,KAAApB,EAAAoB,KAAAvC,KAAAA,KAAAwC,cAAAxC,OCRA,QAAA2B,GAAAC,GAEA5B,KAAAyC,IAAAb,EACA5B,KAAA0C,SAAAN,MAAAO,QAAAC,KAAA5C,MACAA,KAAA6C,cAAA,EACA7C,KAAA8C,gBAAA,EF6BAvD,EAAA4B,GGlCAA,EAAAW,MAAA,SAAA1B,EAAA2C,KAKA5B,EAAAY,QAEAC,SAAA,EAEAgB,KAAA,EAEAC,cAAA,EACAC,cAAA,EACAC,cAAA,EACAC,YAAA,EACAC,oBAAA,EACAC,kBAAA,EACAC,mBAAA,EACAC,mBAAA,GAEAC,WAAA,EACAC,oBAAA,GACAC,kBAAA,GACAC,iBAAA,GAEAC,cAAA,GACAC,gBAAA,GAEAC,YAAA,GACAC,aAAA,GACAC,cAAA,GACAC,iBAAA,GACAC,WAAA,GACAC,aAAA,GACAC,YAAA,GACAC,YAAA,GACAC,aAAA,GAEAC,WAAA,GACAC,iBAAA,GACAC,mBAAA,GACAC,mBAAA,GAEAC,oBAAA,GACAC,oBAAA,GAEAC,eAAA,GACAC,aAAA,GACAC,eAAA,GACAC,aAAA,GACAC,eAAA,GACAC,cAAA,GACAC,cAAA,GACAC,mBAAA,GAEAN,aAAA,GACAO,mBAAA,GACAC,qBAAA,GACAC,kBAAA,GACAC,qBAAA,GAEAC,sBAAA,GAEAC,OAAA,GACAC,QAAA,GAEAC,eAAA,IChEA1E,EAAA2E,KAAA,SAAA1E,EAAA2E,GAIAA,EAAAC,aAAA,KCLA7E,EAAA8E,OAAAC,OAAAC,UAAAC,UAAA,EAEAjF,EAAAkF,cAAA,EAGAlF,EAAAmF,UAAA,WAEAnF,EAAA8E,QAAA,EACA9E,EAAAW,MAAAX,EAAAY,OAAA4D,QACAxE,EAAAF,QAAA,WAIAE,EAAAoF,WAAA,WAEApF,EAAA8E,QAAA,EACA9E,EAAAW,MAAAX,EAAAY,OAAA6D,SACAzE,EAAAF,QAAA,YAKAE,EAAAqF,sBAAA,WAEAN,OAAAO,kBAEAP,OAAAO,iBAAA,SAAAtF,EAAAmF,WAAA,GACAJ,OAAAO,iBAAA,UAAAtF,EAAAoF,YAAA,KAIAG,SAAAC,KAAAC,SAAAzF,EAAAmF,UACAI,SAAAC,KAAAE,UAAA1F,EAAAoF,aAKApF,EAAA2F,mBAAA,WAEA,GAAAb,GAAAC,OAAAC,UAAAC,MAEAjF,GAAAkF,eAEAJ,GAAA,GAGAA,KAAA,GAAA9E,EAAA8E,UAAA,EAEA9E,EAAAmF,YAGAL,KAAA,GAAA9E,EAAA8E,UAAA,GAEA9E,EAAAoF,cJ3CAjF,EAAAI,WAIAqF,cAAA,EAGAC,YAAA,WAEA,MAAA9J,MAIA+J,QAAA,WAEA,GAAAC,GAAAlH,KAAAtB,UAEA,IAAA7C,EAAAqL,GAEAlH,KAAAqC,OAAA8E,KAAAD,OAEA,IAAAjL,EAAAiL,GACA,CACA,GAAAE,GAAA,CAEA,OAAAF,EAAA5I,OAAA,KAEA4I,EAAAA,EAAAjK,UAAA,GACAmK,EAAA,IAGApH,KAAAqC,OAAA8E,KAAA,SAAArI,EAAAC,GAEA,MAAAqI,GAAA/H,EAAAP,EAAAoI,GAAAnI,EAAAmI,MAIAlH,KAAAiB,QAAA,YAKAoG,cAAA,SAAAC,EAAAC,EAAAhG,GAEA,GAAAK,GAAA5B,KACAuH,EAAAA,GAAAD,EAAA1F,EAAA2F,KACAhG,EAAAA,GAAAK,EAAAS,OAAAmF,IAAAD,GACAE,EAAA7F,EAAA8F,OAAA3J,EAAAuJ,GAEA,IAAA/F,GAAAA,EAAAoG,OACA,CACA,GAAAC,GAAArG,EAAAsG,SAEA,KAAA,GAAAvK,KAAAgK,GACA,CACA,GAAAQ,GAAAF,EAAAtK,GACAyK,EAAAxG,EAAAoG,OAAArK,EAEAuB,GAAAiJ,EAAAC,KAEAxG,EAAAjE,GAAAmK,EAAAnK,GACAiE,EAAAyG,OAAA1K,GAAAgK,EAAAhK,IAGAiE,EAAAoG,OAAArK,GAAAS,EAAAuJ,EAAAhK,IAGAiE,EAAA0G,OAAA,WAIA,MAFA9G,GAAAW,MAAAX,EAAAY,OAAAkB,cAAAqE,EAAA/F,GAEAK,EAAAO,MAAA+F,KAAA3G,EAAAyG,cAKAzG,GAAAK,EAAAuG,YAAAV,GAEAlG,EAAAyG,OAAAV,EACA/F,EAAAoG,OAAApG,EAAAyG,OAAAL,OAAA5J,EAAAuJ,GAEA/F,EAAA0G,OAAA,WAIA,MAFA9G,GAAAW,MAAAX,EAAAY,OAAAmB,cAAAoE,EAAA/F,GAEAK,EAAAO,MAAA+F,KAAA3G,EAAAyG,UAGApG,EAAAS,OAAA+F,IAAAb,EAAAhG,EAKA,OAFAA,GAAAN,QAAA,SAEAM,GAIA8G,kBAAA,SAAAd,GAEA,GAAA3F,GAAA5B,KACAuB,EAAAK,EAAAS,OAAAmF,IAAAD,EAEA,OAAAhG,GAEAA,EAAA+G,qBAGA/G,GAAAoG,aACApG,GAAAyG,OAAAL,aACApG,GAAAK,EAAA2F,WACAhG,GAAAyG,OAAApG,EAAA2F,KAEAhG,EAAA0G,OAAA,WAEA,MAAArG,GAAAO,MAAA+F,KAAA3G,EAAAyG,WAGA,IAGAzG,EAAA0G,OAAA,WAEA,MAAArG,GAAAO,MAAAoG,OAAAhB,KAEA,GAEA3F,EAAAS,OAAAkG,OAAAhB,GAEAhG,EAAAN,QAAA,WAEAE,EAAAW,MAAAX,EAAAY,OAAAoB,cAAA5B,IAgBA,IAZAK,EAAAO,MAAAoG,OAAAhB,EAAA,SAAAiB,GAEAA,GAEArH,EAAAW,MAAAX,EAAAY,OAAAoB,cAAAqF,MAKA,IAQA3G,KAAA,WAEA,GAAAD,GAAA5B,IAEA4B,GAAA6G,SAAA,GAAArG,OAAAO,QAAAf,GAAA8G,WAEA9G,EAAAO,MAAAwG,IAAA,SAAAC,EAAAC,GAEA1H,EAAAW,MAAAX,EAAAY,OAAA0B,WAAAmF,GAEAhH,EAAAS,OAAAyG,OAEA,KAAA,GAAAlL,GAAA,EAAAA,EAAAgL,EAAA/K,OAAAD,IACA,CACA,GAAA0J,GAAAsB,EAAAhL,GACA2J,EAAAsB,EAAAjL,GACA6J,EAAA7F,EAAA8F,OAAA3J,EAAAuJ,GAAA,IACAyB,EAAAnH,EAAAuG,YAAAV,EAEAsB,GAAAf,OAAAV,EAEAA,EAAA0B,UAEA7H,EAAAW,MAAAX,EAAAY,OAAA2B,oBAAAqF,GAEAnH,EAAAqH,aAAAF,KAIAzB,EAAAK,OAQAxG,EAAAW,MAAAX,EAAAY,OAAA6B,iBAAAmF,IANA5H,EAAAW,MAAAX,EAAAY,OAAA4B,kBAAAoF,GAEAnH,EAAAsH,WAAAH,IAOAnH,EAAAS,OAAA+F,IAAAb,EAAAwB,IAIAnH,EAAAqF,UAEArF,EAAAuH,gBAKAA,WAAA,WAEA,GAAAvH,GAAA5B,KAEAoJ,EAAA,GAAAhH,OAAAO,QAAA3C,MAEAoB,GACAiI,OAAA,MACAC,IAAAtJ,KAAA8F,KAGA3E,GAAA2E,KAAA1E,EAAAgI,GAEAA,EAAAG,KACA,SAAAlH,GAIA,IAAA,GAFAmH,MAEA5L,EAAA,EAAAA,EAAAyE,EAAAxE,OAAAD,IACA,CACA,GAAA2D,GAAAK,EAAAyF,cAAAhF,EAAAzE,IACA2J,EAAAhG,EAAAkI,MAEAD,GAAAjC,GAAAhG,EAKA,IAAA,GAFAsH,GAAAjH,EAAAS,OAAAwG,KAEAjL,EAAA,EAAAA,EAAAiL,EAAAhL,OAAAD,IACA,CACA,GAAA0C,GAAAuI,EAAAjL,EAEA,MAAA0C,IAAAkJ,IACA,CACA,GAAA/K,GAAAmD,EAAAS,OAAAmF,IAAAlH,EAEA7B,GAAAkJ,SAEAxG,EAAAW,MAAAX,EAAAY,OAAAwB,mBAAAjD,GAEAsB,EAAAyG,kBAAA/H,KAKAsB,EAAAqF,UAEA9F,EAAAW,MAAAX,EAAAY,OAAAqB,YAAAf,IAEA,SAAAA,EAAAqH,GAEA,IAAAA,GAEAvI,EAAA2F,qBAEA3F,EAAA8E,SAEArE,EAAAmF,cAAA,EAEA5F,EAAAlB,KAAA,SAAA,WAEAkB,EAAAW,MAAAX,EAAAY,OAAAyB,oBAEA5B,EAAAmF,eAEAnF,EAAAmF,cAAA,EAEAnF,EAAAuH,iBAKAhI,EAAAW,MAAAX,EAAAY,OAAAsB,sBAIAlC,EAAAW,MAAAX,EAAAY,OAAAuB,kBAAAoG,MAOAC,UAAA,WAEA,MAAA3J,MAAAqC,OAAAuH,QAIApH,cAAA,SAAAZ,GAEA,MAAA,UAAAiI,GAEA,GAAAtC,GAAAsC,EAAAtC,IACAD,EAAAuC,EAAAtI,KAEA,QAAAsI,EAAAC,IAEA,IAAA,OAEAlI,EAAAyF,cAAAC,EAAAC,GACA3F,EAAAqF,UAEA9F,EAAAW,MAAAX,EAAAY,OAAA8B,cAAAgG,EAAAtI,MACA,MAEA,KAAA,SAEAK,EAAAyG,kBAAAd,IAEA3F,EAAAqF,UAGA9F,EAAAW,MAAAX,EAAAY,OAAA+B,gBAAAyD,MAOAY,YAAA,SAAApF,GAEA,MAAA,IAAA/C,MAAAuB,MAAAwB,IAIAgH,OAAA,SAAAhH,GAEA,MAAAA,IAIA2E,OAAA,SAAAsC,GAEA,MAAAA,IAIAC,eAAA,SAAAlE,EAAAsD,EAAAa,GAEA,GAAAtI,GAAA5B,IAEA,OAAA+F,GAAAoE,YAEApE,EAAAqE,OAAA,WAEAf,EAAArN,MAAA4F,EAAAsI,MAGA,IAIAnE,EAAAsE,UAEA,IAKAC,iBAAA,SAAAvE,GAEAA,EAAAwE,UAIArB,WAAA,SAAA3H,GAEA,GAAAK,GAAA5B,KACA+F,EAAAxE,EAAAmB,SACA8H,EAAA,GAAApI,OAAAO,QAAApB,EAGA,IAAAA,EAAAyH,SAIA,MAFA7H,GAAAW,MAAAX,EAAAY,OAAA6C,oBAAArD,GAEAwE,CAIA,IAAAnE,EAAAqI,eAAAlE,EAAA/F,KAAAkJ,WAAAuB,WAIA,MAFAtJ,GAAAW,MAAAX,EAAAY,OAAA8C,oBAAAtD,GAEAwE,CAGA,IAAAuB,GAAA/F,EAAAsG,UAGA6C,EAAAnJ,EAAAoG,OACApJ,EAAA+I,EAAA/F,EAAAoG,OAAA/F,EAAA+I,OAAA9L,GACAyI,CAGA,IAAA1I,EAAA8L,GAEA,MAAA3E,GAAA2C,UAGA,IAAAnB,GAAAhG,EAAAkI,OAGArI,GACAiI,OAAA9H,EAAAoG,OAAA,MAAA,OACA2B,IAAA/H,EAAAoG,OAAA/F,EAAAkE,KAAAyB,EAAA3F,EAAAkE,KACA/C,KAAA2H,EAEAvJ,GAAA2E,KAAA1E,EAAAoJ,EAGA,IAAAI,GAAA,SAAA7H,GAGA,GAAAxB,EAAAyH,SAIA,MAFA7H,GAAAW,MAAAX,EAAAY,OAAA6C,oBAAArD,EAAAwB,GAEAgD,EAAAC,UAIA,KAAA,GAAA1I,KAAAyF,GAEAzF,IAAAoN,KAEAA,EAAApN,GAAAyF,EAAAzF,GAIA6D,GAAAW,MAAAX,EAAAY,OAAAgC,YAAA2G,EAAAnJ,GAIAA,EAAAoG,SAEApG,EAAAoG,OAAApG,EAAAyG,OAAAL,WAIA/F,EAAAyF,cAAAqD,EAAAnD,EAAAhG,GAGAwE,EAAA2C,WAEAvH,EAAAW,MAAAX,EAAAY,OAAAiC,aAAA0G,EAAAnJ,GAGAK,EAAAW,MACAuH,GAAA,OACAvI,MAAAmJ,EACAnD,IAAAA,IA2EA,OAvEAiD,GAAAjB,KACA,SAAAxG,GAEA5B,EAAAW,MAAAX,EAAAY,OAAAuC,YAAA/C,GAGAqJ,EAAA7H,IAEA,SAAAA,EAAA2G,GAGA,MAAAA,GAEAvI,EAAAW,MAAAX,EAAAY,OAAAkC,cAAAlB,EAAAxB,GAGAqJ,EAAA7H,IAEA,MAAA2G,GAAA,MAAAA,GAEAvI,EAAAW,MAAAX,EAAAY,OAAAmC,iBAAA3C,GAEAwE,EAAAC,WAEAzE,EAAA0G,OAAA,WAIA,MAFArG,GAAAS,OAAAkG,OAAAhB,GAEA3F,EAAAO,MAAAoG,OAAAhB,MAGA,IAAAmC,GAEAvI,EAAAW,MAAAX,EAAAY,OAAAoC,WAAA5C,EAAAmI,GAEA3D,EAAAC,aAKA7E,EAAA2F,qBAGA3F,EAAA8E,OAoBAF,EAAAC,YAlBAzE,EAAAsB,cAAA,EAEA1B,EAAAlB,KAAA,SAAA,WAEAsB,EAAAsB,eAEAtB,EAAAsB,cAAA,EAEA1B,EAAAW,MAAAX,EAAAY,OAAAsC,YAAA9C,GAEAK,EAAAsH,WAAA3H,GAAA,MAIAwE,EAAA2C,YAOAvH,EAAAW,MAAAX,EAAAY,OAAAqC,aAAA7C,MAKAwE,GAIAmC,KAAA,SAAA3G,GAEA,GAAAK,GAAA5B,KACA+F,EAAAxE,EAAAmB,SACA6E,EAAAhG,EAAAkI,MAGA,OAAAlI,GAAAyH,UAEA7H,EAAAW,MAAAX,EAAAY,OAAAwC,aAAAhD,GAEAwE,IAIAnE,EAAAS,OAAAwI,IAAAtD,KAEA3F,EAAAS,OAAA+F,IAAAb,EAAAhG,GACAK,EAAAqF,WAGArF,EAAAkJ,UAAAvJ,KAIAuJ,UAAA,SAAAvJ,GAEA,GAAAK,GAAA5B,KACA+F,EAAAxE,EAAAmB,SACA4E,EAAA/F,EAAAsG,SAGA,IAAAtG,EAAAyH,SAIA,MAFA7H,GAAAW,MAAAX,EAAAY,OAAA2C,mBAAAnD,GAEAwE,CAIA,IAAAnE,EAAAqI,eAAAlE,EAAA/F,KAAA8K,UAAAL,WAIA,MAFAtJ,GAAAW,MAAAX,EAAAY,OAAA4C,mBAAAoG,OAEAhF,CAIAxE,GAAAyG,OAOA7K,EAAAmK,EAAA/F,EAAAyG,QALAzG,EAAAyG,OAAAV,CASA,IAAA0D,GAAApJ,EAAAO,MAAA+F,KAAA3G,EAAAyG,QAGA4C,EAAA,WAEA7E,EAAA2C,WAEA9G,EAAAsH,WAAA3H,GAkBA,OAfAyJ,GAAAzB,KACA,SAAAjC,GAEAnG,EAAAW,MAAAX,EAAAY,OAAAyC,WAAAjD,GAEAqJ,KAEA,SAAA1J,GAEAC,EAAAW,MAAAX,EAAAY,OAAA0C,iBAAAlD,EAAAL,GAEA0J,MAIA7E,GAIAkD,aAAA,SAAA1H,GAEA,GAAAK,GAAA5B,KACA+F,EAAAxE,EAAAmB,SACA8H,EAAA,GAAApI,OAAAO,QAAApB,GACAgG,EAAAhG,EAAAkI,MAUA,IAPAlI,EAAAsB,cAAA,EACAtB,EAAAyH,UAAA,EAGApH,EAAA0I,iBAAAvE,GAGAnE,EAAAqI,eAAAlE,EAAA/F,KAAAiJ,aAAAwB,WAIA,MAFAtJ,GAAAW,MAAAX,EAAAY,OAAA2D,sBAAAnE,GAEAwE,CAIA,IAAA3E,IACAiI,OAAA,SACAC,IAAAtJ,KAAA8F,KAAAyB,EAEApG,GAAA2E,KAAA1E,EAAAoJ,EAGA,IAAAS,GAAA,WAEA9J,EAAAW,MAAAX,EAAAY,OAAAgD,aAAAwC,EAAAhG,GAGAwE,EAAAmF,QAAAtJ,EAAAO,MAAAoG,OAAAhB,IAGAhG,EAAAN,QAAA,WAGAE,EAAAW,MAAAX,EAAAY,OAAA+C,eAAAyC,EAAAhG,GAEAK,EAAAW,MACAuH,GAAA,SACAvC,IAAAA,IAkDA,OA9CAiD,GAAAjB,KACA,SAAAxG,GAEA5B,EAAAW,MAAAX,EAAAY,OAAAqD,cAAA7D,GAEA0J,KAEA,SAAAlI,EAAA2G,GAEA,MAAAA,GAAA,MAAAA,GAEAvI,EAAAW,MAAAX,EAAAY,OAAAiD,eAAAuC,EAAAhG,GAEA0J,KAEA,IAAAvB,GAEAvI,EAAAW,MAAAX,EAAAY,OAAAkD,aAAAyE,EAAAnC,EAAAhG,GAEAwE,EAAAC,aAKA7E,EAAA2F,qBAGA3F,EAAA8E,OAWAF,EAAAC,YATA7E,EAAAlB,KAAA,SAAA,WAEAkB,EAAAW,MAAAX,EAAAY,OAAAoD,cAAA5D,KAGAwE,EAAA2C,YAOAvH,EAAAW,MAAAX,EAAAY,OAAAmD,eAAA3D,MAKAwE,GAGAoF,YAAA,SAAA5J,GAEA,GAAAK,GAAA5B,KACA+F,EAAAxE,EAAAmB,SACA6E,EAAAhG,EAAAkI,MAMA,IAHA7H,EAAA0I,iBAAAvE,GAGAnE,EAAAqI,eAAAlE,EAAA/F,KAAAmL,YAAAV,WAIA,MAFAtJ,GAAAW,MAAAX,EAAAY,OAAAwD,qBAAAhE,GAEAwE,CAIA,KAAAxE,EAAAyG,OAIA,MAFA7G,GAAAW,MAAAX,EAAAY,OAAAyD,kBAAAjE,GAEAwE,EAAA2C,UAKA,IAAAnH,EAAAoG,OAOA,CAEApG,EAAAyG,OAAAgB,UAAA,CAEA,IAAAgC,GAAApJ,EAAAO,MAAA+F,KAAA3G,EAAAyG,QAEAoD,EAAA,WAGA7J,EAAAoG,QAEA/F,EAAA0I,iBAAAvE,GAEAA,EAAA2C,WAEA9G,EAAAqH,aAAA1H,IAIAwE,EAAA2C,WAIAsC,GAAAzB,KACA,SAAAjC,GAEAnG,EAAAW,MAAAX,EAAAY,OAAAgD,aAAAxD,GAEA6J,KAEA,SAAAlK,GAEAC,EAAAW,MAAAX,EAAAY,OAAAuD,mBAAA/D,EAAAL,GAEAkK,UAvCAjK,GAAAW,MAAAX,EAAAY,OAAA0D,qBAAAlE,GAEAwE,EAAAmF,QAAAtJ,EAAAO,MAAAoG,OAAAhB,GA0CA,OAAAxB,IAGAwC,OAAA,SAAAhH,GAEA,GAAAK,GAAA5B,KACAuH,EAAAhG,EAAAkI,MAsBA,OAnBA7H,GAAAS,OAAAwI,IAAAtD,KAEA3F,EAAAS,OAAAkG,OAAAhB,GACA3F,EAAAqF,WAIA1F,EAAAyH,UAAA,EAIAzH,EAAAsB,eAEA1B,EAAAW,MAAAX,EAAAY,OAAAsD,mBAAA9D,GAEAA,EAAAsB,cAAA,GAIAjB,EAAAuJ,YAAA5J,KAKAhC,EAAA+B,EAAAI,WCvxBAC,EAAAD,WAGA2J,KAAA,SAAA5N,EAAA6N,GAEA5O,EAAAe,GAEAN,EAAAM,EAAAuC,MAEA/D,EAAAwB,IAAA,SAAA6N,IAEAtL,KAAAvC,GAAA6N,IAIAC,KAAA,SAAA9N,EAAAC,GAEA,GAAAlB,EAAAiB,GAEA,MAAAF,GAAAyC,KAAAvC,EAAAC,EAEA,IAAAhB,EAAAe,GACA,CACA,IAAA,GAAAK,KAAAL,GAEAA,EAAAK,GAAAJ,EAAAK,EAAAiC,KAAAlC,IAAAkC,KAAAlC,EAGA,OAAAL,GAEA,MAAAxB,GAAAwB,GAEAC,EAAAK,EAAAiC,KAAAvC,IAAAuC,KAAAvC,GAFA,QAMA+N,MAAA,SAAAC,EAAAC,GAIA,MAFA1L,MAAAqL,KAAAI,EAAAC,GAEA1L,KAAAyC,IAAAyF,KAAAlI,OAGA2L,QAAA,WAEA,MAAA3L,MAAAyC,IAAA8F,OAAAvI,OAGAiI,OAAA,SAAApI,EAAA+L,GAEA,GAAA9N,GAAAkC,KAAA0C,QAaA,OAXAkJ,IAEA9N,EAAAyM,SAGAzM,EAAAsM,OAAA,WAEAtM,EAAAuM,SACAvM,EAAAoN,QAAArL,OAGA/B,GAGAuM,OAAA,SAAA5M,GAEA,GAAAoO,GAAA7L,KAAAyC,IAAAqJ,SACAnB,EAAA3K,KAAAyC,IAAAkI,MAEA,IAAAjO,EAAAmP,GAEA,IAAA,GAAAjO,GAAA,EAAAA,EAAA+M,EAAA9M,OAAAD,IACA,CACA,GAAAN,GAAAqN,EAAA/M,EAEA,IAAAN,IAAAuO,GACA,CACA,GAAAE,GAAAF,EAAAvO,EAEAzB,GAAAkQ,GAEA/L,KAAA1C,GAAAyO,IAIA/L,KAAA1C,GAAAS,EAAAgO,OAKA/L,MAAA1C,GAAA5B,MAMA,KAAA,GAAAkC,GAAA,EAAAA,EAAA+M,EAAA9M,OAAAD,IACA,CACA,GAAAN,GAAAqN,EAAA/M,EAEAoC,MAAA1C,GAAA5B,EAIAsE,KAAAqL,KAAA5N,IAGAoK,QAAA,WAEA,MAAA7H,MAAAyC,IAAAsH,OAAAxM,EAAAyC,KAAAA,KAAAyC,IAAAkI,QAAA,KAGAlB,KAAA,WAEA,GAAAnJ,GAAAN,KAAAyC,IAAA8E,GAEA,OAAAjH,KAAAN,MAAAA,KAAAM,GAAAN,KAAAM,GAAAN,KAAAyC,IAAAuE,eAGAgF,SAAA,WAEA,QAAAhM,KAAA2H,QAGAsE,gBAAA,WAEA,QAAAjM,KAAAgI,QAGAM,YAAA,WAEA,IAAAtI,KAAA2H,OAEA,OAAA,CAGA,IAAAL,GAAAtH,KAAA6H,UACAqE,EAAAlM,KAAA2H,MAEA,KAAA,GAAArK,KAAAgK,GACA,CACA,GAAAQ,GAAAR,EAAAhK,GACAyK,EAAAmE,EAAA5O,EAEA,KAAAuB,EAAAiJ,EAAAC,GAEA,OAAA,EAIA,OAAA,IAKAxI,EAAAoC,EAAAD,WI1MAjG,EAAA0F,MAAAA,GAEA+E","file":"neurosync.min.js","sourcesContent":["(function(global, undefined)\n{\n","\n\nfunction isDefined(x)\n{\n  return typeof x !== 'undefined';\n}\n\nfunction isFunction(x)\n{\n  return !!(x && x.constructor && x.call && x.apply);\n}\n\nfunction isString(x)\n{\n  return typeof x === 'string';\n}\n\nfunction isNumber(x)\n{\n  return typeof x === 'number' && !isNaN(x);\n}\n\nfunction isDate(x)\n{\n  return x instanceof Date;\n}\n\nfunction isRegExp(x)\n{\n  return x instanceof RegExp;\n}\n\nfunction isArray(x)\n{\n  return x instanceof Array;\n}\n\nfunction isObject(x)\n{\n  return x !== null && typeof x === 'object';\n}\n\nfunction toArray(x, split)\n{\n  return x instanceof Array ? x : x.split( split );\n}\n\nfunction S4() \n{\n  return (((1+Math.random())*0x10000)|0).toString(16).substring(1);\n}\n\nfunction uuid() \n{\n    return (S4()+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+S4()+S4());\n}\n\nfunction transfer(from, to)\n{\n  for (var prop in from)\n  {\n    to[ prop ] = from[ prop ];\n  }\n\n  return to;\n}\n\nfunction grab(obj, props, copyValues)\n{\n  var grabbed = {};\n\n  for (var i = 0; i < props.length; i++) \n  {\n    var p = props[ i ];\n\n    if ( p in obj ) \n    {\n      grabbed[ p ] = copyValues ? copy( obj[ p ] ) : obj[ p ];\n    }\n  }\n\n  return grabbed;\n}\n\nfunction copy(x, copyHidden)\n{\n  if (x === void 0)\n  {\n    return x;\n  }\n  if (isArray(x)) \n  {\n    var c = [];\n\n    for (var i = 0; i < x.length; i++) \n    {\n      c.push( copy(x[i]) );\n    }\n    return x;\n  }\n  if (isFunction(x) || typeof x !== 'object' || x === null)\n  {\n    return x;\n  }\n  if (isDate(x))\n  {\n    return new Date( x.getTime() );\n  }\n  if (isRegExp(x))\n  {\n    return new RegExp( x.source, x.toString().match(/[^\\/]*$/)[0] );\n  }\n\n  var c = {};\n\n  for (var prop in x) \n  {\n    if (copyHidden || prop.charAt(0) !== '$')\n    {\n      c[ prop ] = copy( x[prop] );\n    }\n  }\n\n  return c;\n}\n\nfunction diff(curr, old, props, comparator)\n{\n  var d = {};\n\n  for (var i = 0; i < props.length; i++)\n  {\n    var p = props[ i ];\n\n    if (p in curr && p in old && !comparator( curr[ p ], old[ p ] ) )\n    {\n      d[ p ] = copy( curr[ p ] );\n    }\n  }\n\n  return d;\n}\n\nfunction isEmpty(x)\n{\n  if (x === null || x === void 0 || x === 0) \n  {\n    return true;\n  }\n  if (isArray(x)) \n  {\n    return x.length === 0;\n  }\n  if (isDate(x)) \n  {\n    return x.getTime() === 0 || isNaN( x.getTime() );\n  }\n  if (isObject(x)) \n  {\n    for (var prop in x) \n    {\n      return false;\n    }\n    return true;\n  }\n\n  return false;\n}\n\nfunction equalsStrict(a, b)\n{\n  return a === b;\n}\n\nfunction equals(a, b)\n{\n  if (a === b) return true;\n  if (a === null || b === null) return false;\n  if (a !== a && b !== b) return true; // NaN === NaN\n\n  var at = typeof a;\n  var bt = typeof b;\n  if (at !== bt) return false;\n\n  var aa = isArray(a);\n  var ba = isArray(b);\n  if (aa !== ba) return false;\n\n  if (aa) {\n    if (a.length !== b.length) return false;\n    for (var i = 0; i < a.length; i++) {\n      if (!equals(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if (isDate(a)) {\n    return isDate(b) && equals( a.getTime(), b.getTime() );\n  }\n  if (isRegExp(a)) {\n    return isRegExp(b) && a.toString() === b.toString();\n  }\n\n  if (at === 'object') {\n    for (var p in a) {\n      if (p.charAt(0) !== '$' || !isFunction(a[p])) {\n        if (!(p in b) || !equals(a[p], b[p])) {\n          return false;\n        }\n      }\n    }\n    for (var p in b) {\n      if (p.charAt(0) !== '$' || !isFunction(b[p])) {\n        if (!(p in a)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  return false;\n}\n\nfunction compareNumbers(a, b) \n{\n  return (a === b ? 0 : (a < b ? -1 : 1));\n}\n\nfunction compare(a, b)\n{\n  if (a == b) \n  {\n    return 0;\n  }\n  if (isDate(a)) \n  {\n    a = a.getTime();\n  }\n  if (isDate(b)) \n  {\n    b = b.getTime();\n  }\n  if (isNumber(a) && isNumber(b)) \n  {\n    return compareNumbers(a, b);\n  }\n  if (isArray(a) && isArray(b)) \n  {\n    return compareNumbers(a.length, b.length);\n  }\n  \n  return (a + '').localeCompare(b + '');\n}\n","\n/**\n * Adds functions to the given object (or prototype) so you can listen for any \n * number of events on the given object, optionally once. Listeners can be \n * removed later.\n *\n * The following methods will be added to the given target:\n *\n *     target.on( events, callback, [context] )\n *     target.once( events, callback, [context] )\n *     target.off( events, callback )\n *     target.trigger( event, [argument] )\n *\n * Where... \n * - `events` is a string of space delimited events.\n * - `callback` is a function to invoke when the event is triggered.\n * - `context` is an object that should be the `this` when the callback is \n *   invoked. If no context is given the default value is the object which has \n *   the trigger function that was invoked.\n *\n * @method eventize\n * @for Core\n * @param {Object} target The object to add `on`, `once`, `off`, and `trigger` \n *    functions to.\n */\nfunction eventize(target)\n{\n  /**\n   * **See:** {{#crossLink \"Core/eventize:method\"}}{{/crossLink}}\n   * \n   * @class eventize\n   */\n\n  // Adds a listener to $this\n  var onListeners = function($this, property, events, callback, context)\n  {\n    var events = toArray( events, ' ' );\n    \n    if ( !isDefined( $this[ property ] ) )\n    {\n      $this[ property ] = {};\n    }\n    \n    for (var i = 0; i < events.length; i++)\n    {\n      if ( !isDefined( $this[ property ][ events[i] ] ) )\n      {\n        $this[ property ][ events[i] ] = [];\n      }\n      \n      $this[ property ][ events[i] ].push( [ callback, context || $this ] );\n    }\n  };\n  \n  /**\n   * Listens for every occurrence of the given events and invokes the callback\n   * each time any of them are triggered.\n   * \n   * @method on\n   * @for eventize\n   * @param {String|Array|Object} events\n   * @param {Function} callback\n   * @param {Object} [context]\n   * @chainable\n   */\n  target.on = function(events, callback, context)\n  {\n    onListeners( this, '$on', events, callback, context );\n\n    return this;\n  };\n  \n  /**\n   * Listens for the next occurrence for each of the given events and invokes\n   * the callback when any of the events are triggered.\n   * \n   * @method once\n   * @for eventize\n   * @param {String|Array|Object} events\n   * @param {Function} callback\n   * @param {Object} [context]\n   * @chainable\n   */\n  target.once = function(events, callback, context)\n  {\n    onListeners( this, '$once', events, callback, context );\n\n    return this;\n  };\n  \n  // Removes a listener from an array of listeners.\n  var offListeners = function(listeners, event, callback)\n  {\n    if (listeners && event in listeners)\n    {\n      var eventListeners = listeners[ event ];\n      \n      for (var k = eventListeners.length - 1; k >= 0; k--)\n      {\n        if (eventListeners[ k ][0] === callback)\n        {\n          eventListeners.splice( k, 1 );\n        }\n      }  \n    }\n  };\n\n  // Deletes a property from the given object if it exists\n  var deleteProperty = function(obj, prop)\n  {\n    if ( obj && prop in obj )\n    {\n      delete obj[ prop ];\n    }\n  };\n  \n  /**\n   * Stops listening for a given callback for a given set of events.\n   *\n   * **Examples:**\n   *\n   *     target.off();           // remove all listeners\n   *     target.off('a b');      // remove all listeners on events a & b\n   *     target.off(['a', 'b']); // remove all listeners on events a & b\n   *     target.off('a', x);     // remove listener x from event a\n   * \n   * @method off\n   * @for eventize\n   * @param {String|Array|Object} [events]\n   * @param {Function} [callback]\n   * @chainable\n   */\n  target.off = function(events, callback)\n  {\n    // Remove ALL listeners\n    if ( !isDefined( events ) )\n    {\n      deleteProperty( this, '$on' );\n      deleteProperty( this, '$once' );\n    }\n    else\n    {\n      var events = toArray( events, ' ' );\n\n      // Remove listeners for given events\n      if ( !isFunction( callback ) )\n      {\n        for (var i = 0; i < events.length; i++)\n        {\n          deleteProperty( this.$on, events[i] );\n          deleteProperty( this.$once, events[i] );\n        }\n      }\n      // Remove specific listener\n      else\n      {\n        for (var i = 0; i < events.length; i++)\n        {\n          offListeners( this.$on, events[i], callback );\n          offListeners( this.$once, events[i], callback );\n        }\n      }\n    }\n\n    return this;\n  };\n  \n  // Triggers listeneers for the given event\n  var triggerListeners = function(listeners, event, argument, clear)\n  {\n    if (listeners && event in listeners)\n    {\n      var eventListeners = listeners[ event ];\n      var max = eventListeners.length;\n     \n      for (var i = 0; i < max; i++)\n      {\n        var callback = eventListeners[ i ];\n        \n        callback[0].call( callback[1], argument );\n      }\n      \n      if ( clear )\n      {\n        if ( eventListeners.length !== max )\n        {\n          listeners[ event ] = eventListeners.slice( max );  \n        }\n        else\n        {\n          delete listeners[ event ];  \n        }\n      }\n    }\n  };\n  \n  /**\n   * Triggers a single event optionally passing an argument to any listeners.\n   * \n   * @method trigger\n   * @for eventize\n   * @param {String} event\n   * @param {Any} argument\n   * @chainable\n   */\n  target.trigger = function(events, argument)\n  {\n    var events = toArray( events, ' ' );\n\n    for (var i = 0; i < events.length; i++)\n    {\n      var e = events[ i ];\n\n      triggerListeners( this.$on, e, argument, false );\n      triggerListeners( this.$once, e, argument, true );\n    }\n\n    return this;\n  };\n};","\n/*\nnew Neuro({\n  name: 'name',\n  rest: 'http://api/name',\n  pubsub: 'http://url:port',\n  channel: 'houseid',\n  token: 'userid',\n  timestamp: 'updated_at',              // server returns new updated_at & old, old is compared against current\n  key: 'id',\n  fields: ['id', 'name', 'updated_at'],\n//  encode: function() {},\n//  decode: function() {}\n});\n*/\n\nfunction Neuro(options)\n{\n  var database = new NeuroDatabase( options );\n\n  var model = new Function('return function ' + options.className + '(props) { this.$reset( props ) }')();\n  model.prototype = new NeuroModel( database );\n  model.db = database;\n\n  database.model = model;\n  database.init();\n\n  Neuro.debug( Neuro.Events.CREATION, options, database );\n\n  return {\n    Database: database, \n    Model: model\n  };\n}\n\neventize( Neuro );\n","\n\nfunction NeuroDatabase(options)\n{  \n  transfer( options, this );\n\n  this.stork = new Stork( options );\n  this.models = new Stork.FastMap();\n\n  this.live = Neuro.live( this, this.handlePublish( this ) );\n}\n\nNeuroDatabase.prototype =\n{\n\n  // Whether or not there's a load pending until we're online again\n  $pendingLoad: false,\n\n  // The method responsible for generating a key for the models in the database.\n  generateKey: function()\n  {\n    return uuid();\n  },\n\n  // Sorts the models & notifies listeners that the database has been updated.\n  updated: function()\n  {\n    var cmp = this.comparator;\n\n    if ( isFunction( cmp ) )\n    {\n      this.models.sort( cmp );\n    }\n    else if ( isString( cmp ) )\n    {\n      var order = 1;\n\n      if ( cmp.charAt(0) === '-' )\n      {\n        cmp = cmp.substring( 1 );\n        order = -1;\n      }\n\n      this.models.sort(function(a, b)\n      {\n        return order * compare( a[ cmp ], b[ cmp ] );\n      });\n    }\n\n    this.trigger( 'updated' );\n  },\n\n  // Handles when we receive data from the server - either from\n  // a publish, refresh, or values being returned on a save.\n  putRemoteData: function(encoded, key, model)\n  {\n    var db = this;\n    var key = key || encoded[ db.key ];\n    var model = model || db.models.get( key );\n    var decoded = db.decode( copy( encoded ) );\n\n    if ( model && model.$saved )\n    {\n      var current = model.$toJSON();\n\n      for (var prop in encoded)\n      {\n        var currentValue = current[ prop ];\n        var savedValue = model.$saved[ prop ];\n\n        if ( equals( currentValue, savedValue ) )\n        {\n          model[ prop ] = decoded[ prop ];\n          model.$local[ prop ] = encoded[ prop ];\n        }\n\n        model.$saved[ prop ] = copy( encoded[ prop ] );\n      }\n\n      model.$queue(function()\n      {\n        Neuro.debug( Neuro.Events.REMOTE_UPDATE, encoded, model );\n\n        return db.stork.save( model.$local );\n      });\n    }\n    else\n    {\n      model = db.instantiate( decoded );\n\n      model.$local = encoded;\n      model.$saved = model.$local.$saved = copy( encoded );\n\n      model.$queue(function()\n      {\n        Neuro.debug( Neuro.Events.REMOTE_CREATE, encoded, model );\n\n        return db.stork.save( model.$local );\n      });\n\n      db.models.put( key, model );\n    }\n\n    model.trigger('saved');\n\n    return model;\n  },\n\n  // Destroys a model locally because it doesn't exist remotely\n  destroyLocalModel: function(key)\n  {\n    var db = this;\n    var model = db.models.get( key );\n\n    if ( model )\n    {\n      if ( model.$hasChanges() )\n      {\n        // Removed saved history and the current ID\n        delete model.$saved;\n        delete model.$local.$saved;\n        delete model[ db.key ];\n        delete model.$local[ db.key ];\n\n        model.$queue(function()\n        {\n          return db.stork.save( model.$local );\n        });\n     \n        return false;\n      }\n\n      model.$queue(function()\n      {\n        return db.stork.remove( key );\n\n      }, true );\n\n      db.models.remove( key );\n\n      model.trigger('removed');\n\n      Neuro.debug( Neuro.Events.REMOTE_REMOVE, model );\n    }\n    else\n    {\n      db.stork.remove( key, function(removedValue)\n      {\n        if (removedValue) \n        {\n          Neuro.debug( Neuro.Events.REMOTE_REMOVE, removedValue );\n        }\n      });\n\n      // The model didn't exist\n      return false;\n    }\n\n    return true;\n  },\n\n  // Initialize the database by loading local values and on success load\n  // remove values.\n  init: function()\n  {\n    var db = this;\n\n    db.PROMISED = new Stork.Promise( db ).$success();\n\n    db.stork.all(function(records, keys)\n    {\n      Neuro.debug( Neuro.Events.LOCAL_LOAD, records );\n\n      db.models.reset();\n\n      for (var i = 0; i < records.length; i++) \n      {\n        var encoded = records[ i ];\n        var key = keys[ i ];\n        var decoded = db.decode( copy( encoded, true ) );\n        var inst = db.instantiate( decoded );\n\n        inst.$local = encoded;\n\n        if ( encoded.$deleted )\n        {\n          Neuro.debug( Neuro.Events.LOCAL_RESUME_DELETE, inst );\n\n          db.removeRemote( inst );\n        }\n        else\n        {\n          if ( !encoded.$saved )\n          {\n            Neuro.debug( Neuro.Events.LOCAL_RESUME_SAVE, inst );\n\n            db.saveRemote( inst );\n          }\n          else\n          {\n            Neuro.debug( Neuro.Events.LOCAL_LOAD_SAVED, inst );\n          }\n\n          db.models.put( key, inst );\n        }\n      }\n\n      db.updated();\n\n      db.loadRemote();\n    });    \n  },\n\n  // Loads all data remotely\n  loadRemote: function()\n  {\n    var db = this;\n\n    var loadPromise = new Stork.Promise( this );\n\n    var options = {\n      method: 'GET',\n      url: this.rest\n    };\n\n    Neuro.rest( options, loadPromise );\n\n    loadPromise.then(\n      function onModels(models) \n      {\n        var mapped = {};\n\n        for (var i = 0; i < models.length; i++)\n        {\n          var model = db.putRemoteData( models[ i ] );\n          var key = model.$key();\n\n          mapped[ key ] = model;\n        }\n\n        var keys = db.models.keys;\n\n        for (var i = 0; i < keys.length; i++)\n        {\n          var k = keys[ i ];\n\n          if ( !(k in mapped) )\n          {\n            var old = db.models.get( k );\n\n            if ( old.$saved )\n            {\n              Neuro.debug( Neuro.Events.REMOTE_LOAD_REMOVE, k );\n\n              db.destroyLocalModel( k );\n            }\n          }\n        }\n\n        db.updated();\n\n        Neuro.debug( Neuro.Events.REMOTE_LOAD, models );\n      },\n      function onLoadError(models, status) \n      {\n        if ( status === 0 )\n        {\n          Neuro.checkNetworkStatus();\n\n          if ( !Neuro.online )\n          {\n            db.$pendingLoad = true;\n\n            Neuro.once('online', function()\n            {\n              Neuro.debug( Neuro.Events.REMOTE_LOAD_RESUME );\n\n              if ( db.$pendingLoad )\n              {\n                db.$pendingLoad = false;\n\n                db.loadRemote(); \n              }\n            })\n          }\n\n          Neuro.debug( Neuro.Events.REMOTE_LOAD_OFFLINE );\n        }\n        else\n        {\n          Neuro.debug( Neuro.Events.REMOTE_LOAD_ERROR, status );\n        }\n      }\n    );\n  },\n\n  // The reference to all of the models in the database\n  getModels: function()\n  {\n    return this.models.values;\n  }, \n\n  // Crates a function for handling real-time changes\n  handlePublish: function(db)\n  {\n    return function(message)\n    {\n      var key = message.key;\n      var encoded = message.model;\n\n      switch (message.op) \n      {\n      case 'SAVE':\n\n        db.putRemoteData( encoded, key );\n        db.updated();\n\n        Neuro.debug( Neuro.Events.REALTIME_SAVE, message.model );\n        break;\n\n      case 'REMOVE':\n\n        if ( db.destroyLocalModel( key ) )\n        {\n          db.updated(); \n        }\n\n        Neuro.debug( Neuro.Events.REALTIME_REMOVE, key );\n        break;\n      }\n    };\n  },\n\n  // Return an instance of the model with the data as initial values\n  instantiate: function(data)\n  {\n    return new this.model( data );\n  },\n\n  // Converts properties in data into their storable form\n  encode: function(data)\n  {\n    return data;\n  },\n\n  // Converts properties in rawData from their storable form to their desired\n  decode: function(rawData)\n  {\n    return rawData;\n  },\n\n  // Waits for the given promise to finish before proceeding with the method\n  waitForPending: function(promise, method, args)\n  {\n    var db = this;\n\n    if ( promise.$pending() )\n    {\n      promise.either(function()\n      {\n        method.apply( db, args );\n      });\n\n      return true;\n    }\n    else\n    {\n      promise.$reset();\n\n      return false;\n    }\n  },\n\n  // Interrupt a pending promise\n  interruptPending: function(promise)\n  {\n    promise.$clear();\n  },\n\n  // Save a model remotely\n  saveRemote: function(model)\n  {\n    var db = this;\n    var promise = model.$promise;\n    var promiseRest = new Stork.Promise( model );\n\n    // If the model is deleted, return immediately!\n    if ( model.$deleted )\n    {\n      Neuro.debug( Neuro.Events.SAVE_REMOTE_DELETED, model );\n\n      return promise;\n    }\n\n    // Wait for other methods to finish executing\n    if ( db.waitForPending( promise, this.saveRemote, arguments ) )\n    {\n      Neuro.debug( Neuro.Events.SAVE_REMOTE_BLOCKED, model );\n\n      return promise;\n    }\n\n    var encoded = model.$toJSON();\n\n    // The fields that have changed since last save\n    var $saving = model.$saved ? \n      diff( encoded, model.$saved, db.fields, equals ) :\n      encoded;\n\n    // If there's nothing to save, don't bother!\n    if ( isEmpty( $saving ) )\n    {\n      return promise.$success();\n    }\n\n    var key = model.$key();\n\n    // Make the REST call to remove the mdoel\n    var options = {\n      method: model.$saved ? 'PUT' : 'POST',\n      url:    model.$saved ? db.rest + key : db.rest,\n      data:   $saving\n    };\n    Neuro.rest( options, promiseRest );\n\n    // FInish saving the model\n    var finishSave = function(data)\n    {\n      // Check deleted one more time before updating model.\n      if ( model.$deleted )\n      {\n        Neuro.debug( Neuro.Events.SAVE_REMOTE_DELETED, model, data );\n\n        return promise.$failure();\n      }\n\n      // If data was returned, place it in saving to update the model and publish\n      for (var prop in data)\n      {\n        if ( !(prop in $saving ) )\n        {\n          $saving[ prop ] = data[ prop ];\n        }\n      }\n\n      Neuro.debug( Neuro.Events.SAVE_VALUES, $saving, model );\n\n      // If the model hasn't been saved before - create the record where the \n      // local and model point to the same object.\n      if ( !model.$saved )\n      {\n        model.$saved = model.$local.$saved = {};\n      }\n       \n      // Update the model with the return data\n      db.putRemoteData( $saving, key, model );\n\n      // Success!\n      promise.$success();\n\n      Neuro.debug( Neuro.Events.SAVE_PUBLISH, $saving, model );\n\n      // Publish saved data to everyone else\n      db.live({\n        op: 'SAVE',\n        model: $saving,\n        key: key\n      });\n    };\n\n    promiseRest.then(\n      function onRemoteSave(data) \n      {\n        Neuro.debug( Neuro.Events.SAVE_REMOTE, model );\n\n        // Update the model with the data saved and returned\n        finishSave( data );\n      },\n      function onRemoteFailure(data, status) \n      {\n        // A non-zero status means a real problem occurred\n        if ( status === 409 ) // 409 Conflict\n        {\n          Neuro.debug( Neuro.Events.SAVE_CONFLICT, data, model );\n\n          // Update the model with the data saved and returned\n          finishSave( data );\n        }\n        else if ( status === 410 || status === 404 ) // 410 Gone, 404 Not Found\n        {\n          Neuro.debug( Neuro.Events.SAVE_UPDATE_FAIL, model );\n\n          promise.$failure();\n\n          model.$queue(function()\n          {\n            db.models.remove( key );\n\n            return db.stork.remove( key );\n          });\n        }\n        else if ( status !== 0 ) \n        {          \n          Neuro.debug( Neuro.Events.SAVE_ERROR, model, status );\n\n          promise.$failure();\n        } \n        else \n        {\n          // Check the network status right now\n          Neuro.checkNetworkStatus();\n\n          // If not online for sure, try saving once online again\n          if (!Neuro.online) \n          {\n            model.$pendingSave = true;\n\n            Neuro.once('online', function() \n            {\n              if ( model.$pendingSave )\n              { \n                model.$pendingSave = false;\n\n                Neuro.debug( Neuro.Events.SAVE_RESUME, model );\n\n                db.saveRemote( model, true );\n              }\n            });\n\n            promise.$success();\n          } \n          else \n          {\n            promise.$failure();\n          }\n\n          Neuro.debug( Neuro.Events.SAVE_OFFLINE, model );\n        }\n      }\n    );\n\n    return promise;\n  },\n\n  // Save the model locally then try remotely\n  save: function(model)\n  {\n    var db = this;\n    var promise = model.$promise;\n    var key = model.$key();\n\n    // If the model is deleted, return immediately!\n    if ( model.$deleted )\n    {\n      Neuro.debug( Neuro.Events.SAVE_DELETED, model );\n\n      return promise;\n    }\n\n    // Place the model and trigger a database update.\n    if ( !db.models.has( key ) )\n    {\n      db.models.put( key, model );\n      db.updated();\n    }\n\n    return db.saveLocal( model );\n  },\n\n  // Saves the model locally\n  saveLocal: function(model)\n  {\n    var db = this;\n    var promise = model.$promise;\n    var encoded = model.$toJSON();\n\n    // If the model is deleted, return immediately!\n    if ( model.$deleted )\n    {\n      Neuro.debug( Neuro.Events.SAVE_LOCAL_DELETED, model );\n\n      return promise;\n    }\n\n    // Wait for other methods to finish executing\n    if ( db.waitForPending( promise, this.saveLocal, arguments ) )\n    {\n      Neuro.debug( Neuro.Events.SAVE_LOCAL_BLOCKED, mdoel );\n\n      return promise;\n    }\n\n    // If this model doesn't have a local copy yet - create it.\n    if ( !model.$local ) \n    {\n      model.$local = encoded;\n    } \n    else \n    {\n      // Copy to the local copy\n      transfer( encoded, model.$local );\n    }\n\n    // Save the local copy of the model.\n    var localSave = db.stork.save( model.$local );\n\n    // Finishes the local saving\n    var finishSave = function()\n    {\n      promise.$success();\n\n      db.saveRemote( model );\n    };\n\n    localSave.then(\n      function onLocalSave(encoded) \n      {\n        Neuro.debug( Neuro.Events.SAVE_LOCAL, model );\n\n        finishSave();\n      },\n      function onLocalFailure(e) \n      {\n        Neuro.debug( Neuro.Events.SAVE_LOCAL_ERROR, model, e );\n\n        finishSave();\n      }\n    );\n\n    return promise;\n  },\n\n  // Remove remotely\n  removeRemote: function(model)\n  {\n    var db = this;\n    var promise = model.$promise;\n    var promiseRest = new Stork.Promise( model );\n    var key = model.$key();\n    \n    // Cancel any pending saves\n    model.$pendingSave = false;\n    model.$deleted = true;\n\n    // Removals cancel other operations\n    db.interruptPending( promise );\n\n    // Wait for an existing promise to finish\n    if ( db.waitForPending( promise, this.removeRemote, arguments ) )\n    {\n      Neuro.debug( Neuro.Events.REMOVE_REMOTE_BLOCKED, model );\n\n      return promise;\n    }\n\n    // Make the REST call to remove the model\n    var options = {\n      method: 'DELETE',\n      url:    this.rest + key\n    };\n    Neuro.rest( options, promiseRest );\n\n    // Finish removing the model\n    var removeModel = function()\n    {\n      Neuro.debug( Neuro.Events.REMOVE_LOCAL, key, model ); \n\n      // We're done removing when it's removed locally.\n      promise.$bindTo( db.stork.remove( key ) );\n\n      // Notify the model that it's been removed\n      model.trigger('removed');\n\n      // Publish REMOVE\n      Neuro.debug( Neuro.Events.REMOVE_PUBLISH, key, model );\n\n      db.live({\n        op: 'REMOVE',\n        key: key\n      });\n    };\n\n    promiseRest.then(\n      function onRemoteRemove(data) \n      {\n        Neuro.debug( Neuro.Events.REMOVE_REMOTE, model );\n\n        removeModel();\n      },\n      function onRemoteFailure(data, status) \n      {\n        if ( status === 404 || status === 410 )\n        {\n          Neuro.debug( Neuro.Events.REMOVE_MISSING, key, model );\n\n          removeModel();\n        }\n        else if ( status !== 0 ) \n        {\n          Neuro.debug( Neuro.Events.REMOVE_ERROR, status, key, model );\n\n          promise.$failure();\n        } \n        else \n        {\n          // Looks like we're offline!\n          Neuro.checkNetworkStatus();\n\n          // If we are offline, wait until we're online again to resume the delete\n          if (!Neuro.online) \n          {\n            Neuro.once('online', function() \n            {\n              Neuro.debug( Neuro.Events.REMOVE_RESUME, model );\n            });\n\n            promise.$success();\n          } \n          else\n          {\n            promise.$failure();\n          }\n\n          Neuro.debug( Neuro.Events.REMOVE_OFFLINE, model );\n        }\n      }\n    );\n\n    return promise;\n  },\n\n  removeLocal: function(model)\n  {\n    var db = this;\n    var promise = model.$promise;\n    var key = model.$key();\n\n    // Removals cancel other operations\n    db.interruptPending( promise );\n\n    // Wait for an existing promise to finish\n    if ( db.waitForPending( promise, this.removeLocal, arguments ) )\n    {\n      Neuro.debug( Neuro.Events.REMOVE_LOCAL_BLOCKED, model );\n\n      return promise;\n    }\n\n    // If there is no local there's nothing to remove from anywhere!\n    if ( !model.$local )\n    {\n      Neuro.debug( Neuro.Events.REMOVE_LOCAL_NONE, model );\n\n      return promise.$success();\n    }\n\n    // If this model hasn't been saved we only need to remove it from local\n    // storage.\n    if ( !model.$saved )\n    {\n      Neuro.debug( Neuro.Events.REMOVE_LOCAL_UNSAVED, model );\n\n      promise.$bindTo( db.stork.remove( key ) );\n    }\n    else\n    {\n      // Mark local copy as deleted in the event we're not online\n      model.$local.$deleted = true;\n\n      var localSave = db.stork.save( model.$local );\n\n      var localRemove = function()\n      {\n        // If the model is saved, make sure we call removeRemote immediately.\n        if ( model.$saved )\n        {\n          db.interruptPending( promise );\n\n          promise.$success();\n\n          db.removeRemote( model ); \n        }\n        else\n        {\n          promise.$success();\n        }\n      };\n\n      localSave.then(\n        function onLocalRemove(encoded) \n        {\n          Neuro.debug( Neuro.Events.REMOVE_LOCAL, model );\n\n          localRemove();          \n        },\n        function onLocalFailure(e) \n        {\n          Neuro.debug( Neuro.Events.REMOVE_LOCAL_ERROR, model, e );\n\n          localRemove();\n        }\n      );\n    }\n\n    return promise;\n  },\n\n  remove: function(model)\n  {\n    var db = this;\n    var key = model.$key();\n\n    // If we have it in the models, remove it!\n    if ( db.models.has( key ) )\n    {\n      db.models.remove( key );\n      db.updated();\n    }\n\n    // Mark as deleted right away\n    model.$deleted = true;\n\n    // If we're offline and we have a pending save - cancel the pending save.\n    // TODO Add Debug here?\n    if ( model.$pendingSave )\n    {\n      Neuro.debug( Neuro.Events.REMOVE_CANCEL_SAVE, model );\n\n      model.$pendingSave = false; \n    }\n\n    // Remove it locally\n    return db.removeLocal( model );\n  }\n\n};\n\neventize( NeuroDatabase.prototype );","\nfunction NeuroModel(db)\n{\n  this.$db = db;\n  this.$promise = Stork.Promise.Done( this );\n  this.$pendingSave = false;\n  this.$pendingRemove = false;\n\n  /**\n   * @property {NeuroDatabase} $db\n   *           The reference to the database this model is stored in.\n   */\n\n  /**\n   * @property {Stork.Promise} $promise\n   *           The last promise on the model. When this promise completes \n   *           another action can be performed on the model.\n   */\n\n  /**\n   * @property {Object} [$saved]\n   *           An object of encoded data representing the values saved remotely.\n   *           If this object does not exist - the model hasn't been created\n   *           yet.\n   */\n  \n  /**\n   * @property {Boolean} [$deleted]\n   *           A flag placed on a model once it's requested to be deleted. A  \n   *           model with this flag isn't present on any arrays - it's stored\n   *           locally until its successfully removed remotely - then it's \n   *           removed locally.\n   */\n  \n  /**\n   * @property {Object} [$local]\n   *           The object of encoded data that is stored locally. It's $saved\n   *           property is the same object as this $saved property.\n   */\n  \n  /**\n   * @property {Boolean} $pendingSave\n   *           Whether there is a pending save for this model.\n   */\n}\n\nNeuroModel.prototype =\n{\n\n  $set: function(props, value)\n  {\n    if ( isObject( props ) )\n    {\n      transfer( props, this );\n    }\n    else if ( isString( props ) && value !== void 0 )\n    {\n      this[ props ] = value;\n    }\n  },\n\n  $get: function(props, copyValues)\n  {\n    if ( isArray( props ) )\n    {\n      return grab( this, props, copyValues );\n    }\n    else if ( isObject( props ) )\n    {\n      for (var p in props)\n      {\n        props[ p ] = copyValues ? copy( this[ p ] ) : this[ p ];\n      }\n\n      return props;\n    }\n    else if ( isString( props ) )\n    {\n      return copyValues ? copy( this[ props ] ) : this[ props ];\n    }\n  },\n\n  $save: function(setProperties, setValue)\n  {\n    this.$set( setProperties, setValue );\n\n    return this.$db.save( this );\n  },\n\n  $remove: function()\n  {\n    return this.$db.remove( this );\n  },\n\n  $queue: function(callback, interrupt)\n  {\n    var p = this.$promise;\n\n    if (interrupt)\n    {\n      p.$clear();\n    }\n\n    p.either(function()\n    {\n      p.$reset();\n      p.$bindTo( callback() );\n    });\n\n    return p;\n  },\n\n  $reset: function(props)\n  {\n    var def = this.$db.defaults;\n    var fields = this.$db.fields;\n\n    if ( isObject( def ) )\n    {\n      for (var i = 0; i < fields.length; i++)\n      {\n        var prop = fields[ i ];\n\n        if ( prop in def )\n        {\n          var defaultValue = def[ prop ];\n\n          if ( isFunction( defaultValue ) )\n          {\n            this[ prop ] = defaultValue();\n          }\n          else\n          {\n            this[ prop ] = copy( defaultValue );\n          }\n        }\n        else\n        {\n          this[ prop ] = undefined;\n        }\n      }\n    }\n    else\n    {\n      for (var i = 0; i < fields.length; i++)\n      {\n        var prop = fields[ i ];\n\n        this[ prop ] = undefined;\n      }\n    }\n\n    this.$set( props );\n  },\n\n  $toJSON: function()\n  {\n    return this.$db.encode( grab( this, this.$db.fields, true ) );\n  },\n\n  $key: function()\n  {\n    var k = this.$db.key;\n\n    return k in this ? this[ k ] : (this[ k ] = this.$db.generateKey());\n  },\n\n  $isSaved: function()\n  {\n    return !!this.$saved;\n  },\n\n  $isSavedLocally: function()\n  {\n    return !!this.$local;\n  },\n\n  $hasChanges: function()\n  {\n    if (!this.$saved) \n    {\n      return true;\n    }\n\n    var encoded = this.$toJSON();\n    var saved = this.$saved;\n\n    for (var prop in encoded) \n    {\n      var currentValue = encoded[ prop ];\n      var savedValue = saved[ prop ];\n\n      if ( !equals( currentValue, savedValue ) ) \n      {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n};\n\neventize( NeuroModel.prototype );","\nNeuro.debug = function(event, data)\n{\n  // up to the user\n};\n\nNeuro.Events = {\n\n  CREATION: 0,                // options, NeuroDatabase\n\n  REST: 1,                    // options\n\n  REMOTE_UPDATE: 2,           // encoded, NeuroModel\n  REMOTE_CREATE: 3,           // encoded, NeuroModel\n  REMOTE_REMOVE: 4,           // NeuroModel\n  REMOTE_LOAD: 5,             // encoded[]\n  REMOTE_LOAD_OFFLINE: 6,     // \n  REMOTE_LOAD_ERROR: 7,       // status\n  REMOTE_LOAD_REMOVE: 8,      // key\n  REMOTE_LOAD_RESUME: 22,     // \n\n  LOCAL_LOAD: 9,              // encoded[]\n  LOCAL_RESUME_DELETE: 10,    // NeuroModel\n  LOCAL_RESUME_SAVE: 11,      // NeuroModel\n  LOCAL_LOAD_SAVED: 12,       // NeuroModel\n\n  REALTIME_SAVE: 13,          // encoded\n  REALTIME_REMOVE: 14,        // key\n\n  SAVE_VALUES: 15,            // encoded, NeuroModel\n  SAVE_PUBLISH: 16,           // encoded, NeuroModel\n  SAVE_CONFLICT: 17,          // encoded, NeuroModel\n  SAVE_UPDATE_FAIL: 18,       // NeuroModel\n  SAVE_ERROR: 19,             // NeuroModel, status\n  SAVE_OFFLINE: 20,           // NeuroModel\n  SAVE_RESUME: 21,            // NeuroModel\n  SAVE_REMOTE: 25,            // NeuroModel\n  SAVE_DELETED: 40,           // NeuroModel\n\n  SAVE_LOCAL: 23,             // NeuroModel\n  SAVE_LOCAL_ERROR: 24,       // NeuroModel, error\n  SAVE_LOCAL_DELETED: 38,     // NeuroModel\n  SAVE_LOCAL_BLOCKED: 39,     // NeuroModel\n\n  SAVE_REMOTE_DELETED: 41,    // NeuroModel, [encoded]\n  SAVE_REMOTE_BLOCKED: 42,    // NeuroModel\n\n  REMOVE_PUBLISH: 26,         // key, NeuroModel\n  REMOVE_LOCAL: 27,           // key, NeuroModel\n  REMOVE_MISSING: 28,         // key, NeuroModel\n  REMOVE_ERROR: 29,           // status, key, NeuroModel\n  REMOVE_OFFLINE: 30,         // NeuroModel\n  REMOVE_RESUME: 31,          // NeuroModel\n  REMOVE_REMOTE: 32,          // NeuroModel\n  REMOVE_CANCEL_SAVE: 47,     // NeuroModel\n\n  REMOVE_LOCAL: 33,           // NeuroModel\n  REMOVE_LOCAL_ERROR: 34,     // NeuroModel, error\n  REMOVE_LOCAL_BLOCKED: 44,   // NeuroModel\n  REMOVE_LOCAL_NONE: 45,      // NeuroModel\n  REMOVE_LOCAL_UNSAVED: 46,   // NeuroModel\n\n  REMOVE_REMOTE_BLOCKED: 43,  // NeuroModel\n\n  ONLINE: 35,                 //\n  OFFLINE: 36,                //\n\n  PUBSUB_CREATED: 37          // PubSub\n\n};","\n// Neuro.rest = function(options, success(data), failure(data, status))\n\nNeuro.rest = function(options, promise)\n{\n  // success ( data )\n  // failure ( data, status )\n  promise.$failure( [{}, 0] );\n};","\n// Initial online\nNeuro.online = window.navigator.onLine !== false;\n\nNeuro.forceOffline = false;\n\n// Set network status to online and notify all listeners\nNeuro.setOnline = function()\n{\n  Neuro.online = true;\n  Neuro.debug( Neuro.Events.ONLINE );\n  Neuro.trigger('online');\n};\n\n// Set network status to offline and notify all listeners\nNeuro.setOffline = function()\n{\n  Neuro.online = false;\n  Neuro.debug( Neuro.Events.OFFLINE );\n  Neuro.trigger('offline');\n};\n\n// This must be called manually - this will try to use built in support for \n// online/offline detection instead of solely using status codes of 0.\nNeuro.listenToNetworkStatus = function()\n{\n  if (window.addEventListener) \n  {\n    window.addEventListener( 'online', Neuro.setOnline, false );\n    window.addEventListener( 'offline', Neuro.setOffline, false );\n  } \n  else \n  {\n    document.body.ononline = Neuro.setOnline;\n    document.body.onoffline = Neuro.setOffline;\n  }\n};\n\n// Check to see if the network status has changed.\nNeuro.checkNetworkStatus = function()\n{\n  var online = window.navigator.onLine;\n\n  if ( Neuro.forceOffline ) \n  {\n    online = false;\n  }\n\n  if (online === true && Neuro.online === false) \n  {\n    Neuro.setOnline();\n  }\n\n  else if (online === false && Neuro.online === true) \n  {\n    Neuro.setOffline();\n  }\n};","\n  global.Neuro = Neuro;\n\n})(window);"],"sourceRoot":"/source/"}