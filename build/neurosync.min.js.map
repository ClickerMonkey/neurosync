{"version":3,"sources":["header.js","functions.js","eventize.js","Neuro.js","NeuroDatabase.js","NeuroModel.js","NeuroMap.js","NeuroOperation.js","NeuroRemoveLocal.js","NeuroRemoveNow.js","NeuroRemoveRemote.js","NeuroSaveLocal.js","NeuroSaveNow.js","NeuroSaveRemote.js","Neuro_debug.js","Neuro_rest.js","Neuro_store.js","Neuro_live.js","Neuro_offline.js","footer.js"],"names":["global","undefined","isDefined","x","isFunction","constructor","call","apply","isString","isNumber","isNaN","isDate","Date","isRegExp","RegExp","isArray","Array","isObject","toArray","split","S4","Math","random","toString","substring","uuid","transfer","from","to","prop","swap","a","i","k","t","grab","obj","props","copyValues","grabbed","length","p","copy","copyHidden","c","push","getTime","source","match","charAt","diff","curr","old","comparator","d","isEmpty","equals","b","at","bt","aa","ba","compareNumbers","compare","localeCompare","eventize","target","onListeners","$this","property","events","callback","context","on","this","once","offListeners","listeners","event","eventListeners","splice","deleteProperty","off","$on","$once","triggerListeners","args","clear","max","slice","trigger","e","Neuro","options","database","NeuroDatabase","model","Function","className","prototype","NeuroModel","init","debug","Events","CREATION","Database","Model","models","NeuroMap","rest","store","live","handlePublish","relations","setComparator","db","$db","values","keys","indices","NeuroOperation","interrupts","NeuroRemoveLocal","reset","NeuroRemoveNow","NeuroRemoveRemote","NeuroSaveLocal","NeuroSaveNow","NeuroSaveRemote","data","REST","REMOTE_UPDATE","REMOTE_CREATE","REMOTE_REMOVE","REMOTE_LOAD","REMOTE_LOAD_OFFLINE","REMOTE_LOAD_ERROR","REMOTE_LOAD_REMOVE","REMOTE_LOAD_RESUME","LOCAL_LOAD","LOCAL_RESUME_DELETE","LOCAL_RESUME_SAVE","LOCAL_LOAD_SAVED","REALTIME_SAVE","REALTIME_REMOVE","SAVE_VALUES","SAVE_PUBLISH","SAVE_CONFLICT","SAVE_UPDATE_FAIL","SAVE_ERROR","SAVE_OFFLINE","SAVE_RESUME","SAVE_REMOTE","SAVE_DELETED","SAVE_LOCAL","SAVE_LOCAL_ERROR","SAVE_LOCAL_DELETED","SAVE_LOCAL_BLOCKED","SAVE_REMOTE_DELETED","SAVE_REMOTE_BLOCKED","REMOVE_PUBLISH","REMOVE_LOCAL","REMOVE_MISSING","REMOVE_ERROR","REMOVE_OFFLINE","REMOVE_RESUME","REMOVE_REMOTE","REMOVE_CANCEL_SAVE","REMOVE_LOCAL_ERROR","REMOVE_LOCAL_BLOCKED","REMOVE_LOCAL_NONE","REMOVE_LOCAL_UNSAVED","REMOVE_REMOTE_BLOCKED","ONLINE","OFFLINE","PUBSUB_CREATED","success","failure","put","key","record","remove","all","onPublish","message","online","window","navigator","onLine","forceOffline","setOnline","setOffline","listenToNetworkStatus","addEventListener","document","body","ononline","onoffline","checkNetworkStatus","pendingRefresh","removeKey","getKey","ks","keySeparator","updated","sort","comparatorFunction","isSorted","n","putRemoteData","encoded","get","decoded","decode","$saved","current","$toJSON","conflicts","conflicted","currentValue","savedValue","$local","$addOperation","instantiate","has","destroyLocalModel","$hasChanges","removedValue","records","$deleted","loadRemote","refresh","onModels","mapped","$key","onLoadError","status","method","url","api","getModels","getModel","keyString","op","encode","rawData","save","$pendingSave","$init","$operation","$relations","$reset","def","defaults","fields","defaultValue","$set","value","relation","set","$get","$save","setProperties","setValue","$remove","OperationType","operation","queue","execute","$isSaved","$isSavedLocally","$getChanges","saved","index","removeAt","lastValue","pop","lastKey","size","filter","dest","out","v","reverse","half","ceil","rebuildIndex","partition","left","right","pivot","map","floor","j","qsort","l","next","finished","run","finish","tryNext","insertNext","onSuccess","arguments","onFailure","previousValue","finishRemove","saving","handleData"],"mappings":"CAAA,SAAAA,EAAAC,GCEA,QAAAC,GAAAC,GAEA,MAAA,mBAAAA,GAGA,QAAAC,GAAAD,GAEA,SAAAA,GAAAA,EAAAE,aAAAF,EAAAG,MAAAH,EAAAI,OAGA,QAAAC,GAAAL,GAEA,MAAA,gBAAAA,GAGA,QAAAM,GAAAN,GAEA,MAAA,gBAAAA,KAAAO,MAAAP,GAGA,QAAAQ,GAAAR,GAEA,MAAAA,aAAAS,MAGA,QAAAC,GAAAV,GAEA,MAAAA,aAAAW,QAGA,QAAAC,GAAAZ,GAEA,MAAAA,aAAAa,OAGA,QAAAC,GAAAd,GAEA,MAAA,QAAAA,GAAA,gBAAAA,GAGA,QAAAe,GAAAf,EAAAgB,GAEA,MAAAhB,aAAAa,OAAAb,EAAAA,EAAAgB,MAAAA,GAkBA,QAAAC,KAEA,OAAA,OAAA,EAAAC,KAAAC,UAAA,GAAAC,SAAA,IAAAC,UAAA,GAGA,QAAAC,KAEA,MAAAL,KAAAA,IAAA,IAAAA,IAAA,IAAAA,IAAA,IAAAA,IAAA,IAAAA,IAAAA,IAAAA,IAsCA,QAAAM,GAAAC,EAAAC,GAEA,IAAA,GAAAC,KAAAF,GAEAC,EAAAC,GAAAF,EAAAE,EAGA,OAAAD,GAGA,QAAAE,GAAAC,EAAAC,EAAAC,GAEA,GAAAC,GAAAH,EAAAC,EACAD,GAAAC,GAAAD,EAAAE,GACAF,EAAAE,GAAAC,EAGA,QAAAC,GAAAC,EAAAC,EAAAC,GAIA,IAAA,GAFAC,MAEAP,EAAA,EAAAA,EAAAK,EAAAG,OAAAR,IACA,CACA,GAAAS,GAAAJ,EAAAL,EAEAS,KAAAL,KAEAG,EAAAE,GAAAH,EAAAI,EAAAN,EAAAK,IAAAL,EAAAK,IAIA,MAAAF,GAGA,QAAAG,GAAAvC,EAAAwC,GAEA,GAAA,SAAAxC,EAEA,MAAAA,EAEA,IAAAY,EAAAZ,GACA,CAGA,IAAA,GAFAyC,MAEAZ,EAAA,EAAAA,EAAA7B,EAAAqC,OAAAR,IAEAY,EAAAC,KAAAH,EAAAvC,EAAA6B,IAEA,OAAA7B,GAEA,GAAAC,EAAAD,IAAA,gBAAAA,IAAA,OAAAA,EAEA,MAAAA,EAEA,IAAAQ,EAAAR,GAEA,MAAA,IAAAS,MAAAT,EAAA2C,UAEA,IAAAjC,EAAAV,GAEA,MAAA,IAAAW,QAAAX,EAAA4C,OAAA5C,EAAAoB,WAAAyB,MAAA,WAAA,GAGA,IAAAJ,KAEA,KAAA,GAAAf,KAAA1B,IAEAwC,GAAA,MAAAd,EAAAoB,OAAA,MAEAL,EAAAf,GAAAa,EAAAvC,EAAA0B,IAIA,OAAAe,GAGA,QAAAM,GAAAC,EAAAC,EAAAf,EAAAgB,GAIA,IAAA,GAFAC,MAEAtB,EAAA,EAAAA,EAAAK,EAAAG,OAAAR,IACA,CACA,GAAAS,GAAAJ,EAAAL,EAEAS,KAAAU,IAAAV,IAAAW,KAAAC,EAAAF,EAAAV,GAAAW,EAAAX,MAEAa,EAAAb,GAAAC,EAAAS,EAAAV,KAIA,MAAAa,GAGA,QAAAC,GAAApD,GAEA,GAAA,OAAAA,GAAA,SAAAA,GAAA,IAAAA,EAEA,OAAA,CAEA,IAAAY,EAAAZ,GAEA,MAAA,KAAAA,EAAAqC,MAEA,IAAA7B,EAAAR,GAEA,MAAA,KAAAA,EAAA2C,WAAApC,MAAAP,EAAA2C,UAEA,IAAA7B,EAAAd,GACA,CACA,IAAA,GAAA0B,KAAA1B,GAEA,OAAA,CAEA,QAAA,EAGA,OAAA,EAQA,QAAAqD,GAAAzB,EAAA0B,GAEA,GAAA1B,IAAA0B,EAAA,OAAA,CACA,IAAA,OAAA1B,GAAA,OAAA0B,EAAA,OAAA,CACA,IAAA1B,IAAAA,GAAA0B,IAAAA,EAAA,OAAA,CAEA,IAAAC,SAAA3B,GACA4B,QAAAF,EACA,IAAAC,IAAAC,EAAA,OAAA,CAEA,IAAAC,GAAA7C,EAAAgB,GACA8B,EAAA9C,EAAA0C,EACA,IAAAG,IAAAC,EAAA,OAAA,CAEA,IAAAD,EAAA,CACA,GAAA7B,EAAAS,SAAAiB,EAAAjB,OAAA,OAAA,CACA,KAAA,GAAAR,GAAA,EAAAA,EAAAD,EAAAS,OAAAR,IACA,IAAAwB,EAAAzB,EAAAC,GAAAyB,EAAAzB,IACA,OAAA,CAGA,QAAA,EAGA,GAAArB,EAAAoB,GACA,MAAApB,GAAA8C,IAAAD,EAAAzB,EAAAe,UAAAW,EAAAX,UAEA,IAAAjC,EAAAkB,GACA,MAAAlB,GAAA4C,IAAA1B,EAAAR,aAAAkC,EAAAlC,UAGA,IAAA,WAAAmC,EAAA,CACA,IAAA,GAAAjB,KAAAV,GACA,KAAA,MAAAU,EAAAQ,OAAA,IAAA7C,EAAA2B,EAAAU,KACAA,IAAAgB,IAAAD,EAAAzB,EAAAU,GAAAgB,EAAAhB,KACA,OAAA,CAIA,KAAA,GAAAA,KAAAgB,GACA,KAAA,MAAAhB,EAAAQ,OAAA,IAAA7C,EAAAqD,EAAAhB,KACAA,IAAAV,IACA,OAAA,CAIA,QAAA,EAGA,OAAA,EAGA,QAAA+B,GAAA/B,EAAA0B,GAEA,MAAA1B,KAAA0B,EAAA,EAAAA,EAAA1B,EAAA,GAAA,EAGA,QAAAgC,GAAAhC,EAAA0B,GAEA,MAAA1B,IAAA0B,EAEA,GAEA9C,EAAAoB,KAEAA,EAAAA,EAAAe,WAEAnC,EAAA8C,KAEAA,EAAAA,EAAAX,WAEArC,EAAAsB,IAAAtB,EAAAgD,GAEAK,EAAA/B,EAAA0B,GAEA1C,EAAAgB,IAAAhB,EAAA0C,GAEAK,EAAA/B,EAAAS,OAAAiB,EAAAjB,SAGAT,EAAA,IAAAiC,cAAAP,EAAA,KC9RA,QAAAQ,GAAAC,GASA,GAAAC,GAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAEA,GAAAF,GAAApD,EAAAoD,EAAA,IAEApE,GAAAkE,EAAAC,MAEAD,EAAAC,MAGA,KAAA,GAAArC,GAAA,EAAAA,EAAAsC,EAAA9B,OAAAR,IAEA9B,EAAAkE,EAAAC,GAAAC,EAAAtC,OAEAoC,EAAAC,GAAAC,EAAAtC,QAGAoC,EAAAC,GAAAC,EAAAtC,IAAAa,MAAA0B,EAAAC,GAAAJ,IAeAF,GAAAO,GAAA,SAAAH,EAAAC,EAAAC,GAIA,MAFAL,GAAAO,KAAA,MAAAJ,EAAAC,EAAAC,GAEAE,MAcAR,EAAAS,KAAA,SAAAL,EAAAC,EAAAC,GAIA,MAFAL,GAAAO,KAAA,QAAAJ,EAAAC,EAAAC,GAEAE,KAIA,IAAAE,GAAA,SAAAC,EAAAC,EAAAP,GAEA,GAAAM,GAAAC,IAAAD,GAIA,IAAA,GAFAE,GAAAF,EAAAC,GAEA7C,EAAA8C,EAAAvC,OAAA,EAAAP,GAAA,EAAAA,IAEA8C,EAAA9C,GAAA,KAAAsC,GAEAQ,EAAAC,OAAA/C,EAAA,IAOAgD,EAAA,SAAA7C,EAAAP,GAEAO,GAAAP,IAAAO,UAEAA,GAAAP,GAoBAqC,GAAAgB,IAAA,SAAAZ,EAAAC,GAGA,GAAArE,EAAAoE,GAMA,CACA,GAAAA,GAAApD,EAAAoD,EAAA,IAGA,IAAAlE,EAAAmE,GAWA,IAAA,GAAAvC,GAAA,EAAAA,EAAAsC,EAAA9B,OAAAR,IAEA4C,EAAAF,KAAAS,IAAAb,EAAAtC,GAAAuC,GACAK,EAAAF,KAAAU,MAAAd,EAAAtC,GAAAuC,OAZA,KAAA,GAAAvC,GAAA,EAAAA,EAAAsC,EAAA9B,OAAAR,IAEAiD,EAAAP,KAAAS,IAAAb,EAAAtC,IACAiD,EAAAP,KAAAU,MAAAd,EAAAtC,QAbAiD,GAAAP,KAAA,OACAO,EAAAP,KAAA,QA0BA,OAAAA,MAIA,IAAAW,GAAA,SAAAR,EAAAC,EAAAQ,EAAAC,GAEA,GAAAV,GAAAC,IAAAD,GACA,CAIA,IAAA,GAHAE,GAAAF,EAAAC,GACAU,EAAAT,EAAAvC,OAEAR,EAAA,EAAAwD,EAAAxD,EAAAA,IACA,CACA,GAAAuC,GAAAQ,EAAA/C,EAEAuC,GAAA,GAAAhE,MAAAgE,EAAA,GAAAe,GAGAC,IAEAR,EAAAvC,SAAAgD,EAEAX,EAAAC,GAAAC,EAAAU,MAAAD,SAIAX,GAAAC,KAeAZ,GAAAwB,QAAA,SAAApB,EAAAgB,GAIA,IAAA,GAFAhB,GAAApD,EAAAoD,EAAA,KAEAtC,EAAA,EAAAA,EAAAsC,EAAA9B,OAAAR,IACA,CACA,GAAA2D,GAAArB,EAAAtC,EAEAqD,GAAAX,KAAAS,IAAAQ,EAAAL,GAAA,GACAD,EAAAX,KAAAU,MAAAO,EAAAL,GAAA,GAGA,MAAAZ,OC1MA,QAAAkB,GAAAC,GAEA,GAAAC,GAAA,GAAAC,GAAAF,GAEAG,EAAA,GAAAC,UAAA,mBAAAJ,EAAAK,UAAA,oCASA,OAPAF,GAAAG,UAAA,GAAAC,GAAAN,GAEAA,EAAAE,MAAAA,EACAF,EAAAO,OAEAT,EAAAU,MAAAV,EAAAW,OAAAC,SAAAX,EAAAC,IAGAW,SAAAX,EACAY,MAAAV,GC5BA,QAAAD,GAAAF,GAEAnE,EAAAmE,EAAAnB,MAEAA,KAAAiC,OAAA,GAAAC,GAEAlC,KAAAmC,KAAAjB,EAAAiB,KAAAnC,MACAA,KAAAoC,MAAAlB,EAAAkB,MAAApC,MACAA,KAAAqC,KAAAnB,EAAAmB,KAAArC,KAAAA,KAAAsC,cAAAtC,OAEAA,KAAAuC,aAEAvC,KAAAwC,cAAAxC,KAAArB,YCbA,QAAA+C,GAAAe,GAEAzC,KAAA0C,IAAAD,ECMA,QAAAP,KAMAlC,KAAA2C,UAMA3C,KAAA4C,QAMA5C,KAAA6C,WC1BA,QAAAC,GAAAC,GAEA/C,KAAA+C,WAAAA,ECHA,QAAAC,GAAA1B,GAEAtB,KAAAiD,MAAA3B,GCFA,QAAA4B,GAAA5B,GAEAtB,KAAAiD,MAAA3B,GCFA,QAAA6B,GAAA7B,GAEAtB,KAAAiD,MAAA3B,GCFA,QAAA8B,GAAA9B,GAEAtB,KAAAiD,MAAA3B,GCFA,QAAA+B,GAAA/B,GAEAtB,KAAAiD,MAAA3B,GCFA,QAAAgC,GAAAhC,GAEAtB,KAAAiD,MAAA3B,GVgCA/B,EAAA2B,GWjCAA,EAAAU,MAAA,SAAAxB,EAAAmD,KAKArC,EAAAW,QAEAC,SAAA,EAEA0B,KAAA,EAEAC,cAAA,EACAC,cAAA,EACAC,cAAA,EACAC,YAAA,EACAC,oBAAA,EACAC,kBAAA,EACAC,mBAAA,EACAC,mBAAA,GAEAC,WAAA,EACAC,oBAAA,GACAC,kBAAA,GACAC,iBAAA,GAEAC,cAAA,GACAC,gBAAA,GAEAC,YAAA,GACAC,aAAA,GACAC,cAAA,GACAC,iBAAA,GACAC,WAAA,GACAC,aAAA,GACAC,YAAA,GACAC,YAAA,GACAC,aAAA,GAEAC,WAAA,GACAC,iBAAA,GACAC,mBAAA,GACAC,mBAAA,GAEAC,oBAAA,GACAC,oBAAA,GAEAC,eAAA,GACAC,aAAA,GACAC,eAAA,GACAC,aAAA,GACAC,eAAA,GACAC,cAAA,GACAC,cAAA,GACAC,mBAAA,GAEAN,aAAA,GACAO,mBAAA,GACAC,qBAAA,GACAC,kBAAA,GACAC,qBAAA,GAEAC,sBAAA,GAEAC,OAAA,GACAC,QAAA,GAEAC,eAAA,IChEAnF,EAAAiB,KAAA,SAAAf,GAEA,MAAA,UAAAD,EAAAmF,EAAAC,GAKAA,KAAA,KCDArF,EAAAkB,MAAA,SAAAhB,GAEA,OAkBAoF,IAAA,SAAAC,EAAAC,EAAAJ,EAAAC,KAmBAI,OAAA,SAAAF,EAAAH,EAAAC,KAcAK,IAAA,SAAAN,EAAAC,OC/CArF,EAAAmB,KAAA,SAAAjB,EAAAyF,GAEA,MAAA,UAAAC,MCfA5F,EAAA6F,OAAAC,OAAAC,UAAAC,UAAA,EAEAhG,EAAAiG,cAAA,EAGAjG,EAAAkG,UAAA,WAEAlG,EAAA6F,QAAA,EACA7F,EAAAU,MAAAV,EAAAW,OAAAsE,QACAjF,EAAAF,QAAA,WAIAE,EAAAmG,WAAA,WAEAnG,EAAA6F,QAAA,EACA7F,EAAAU,MAAAV,EAAAW,OAAAuE,SACAlF,EAAAF,QAAA,YAKAE,EAAAoG,sBAAA,WAEAN,OAAAO,kBAEAP,OAAAO,iBAAA,SAAArG,EAAAkG,WAAA,GACAJ,OAAAO,iBAAA,UAAArG,EAAAmG,YAAA,KAIAG,SAAAC,KAAAC,SAAAxG,EAAAkG,UACAI,SAAAC,KAAAE,UAAAzG,EAAAmG,aAKAnG,EAAA0G,mBAAA,WAEA,GAAAb,GAAAC,OAAAC,UAAAC,MAEAhG,GAAAiG,eAEAJ,GAAA,GAGAA,KAAA,GAAA7F,EAAA6F,UAAA,EAEA7F,EAAAkG,YAGAL,KAAA,GAAA7F,EAAA6F,UAAA,GAEA7F,EAAAmG,cdtCAhG,EAAAI,WAIAoG,gBAAA,EAGAC,UAAA,SAAAxG,GAEA,GAAA/D,GAAAyC,KAAAyG,GAEA,IAAApK,EAAAkB,GAEA,IAAA,GAAAD,GAAA,EAAAA,EAAAC,EAAAO,OAAAR,UAEAgE,GAAA/D,EAAAD,eAKAgE,GAAA/D,IAKAwK,OAAA,SAAAzG,GAEA,GAAA/D,GAAAyC,KAAAyG,IACAA,EAAA,IAEA,IAAApK,EAAAkB,GACA,CACA,GAAAyK,GAAAhI,KAAAiI,cAAA,GAEAxB,GAAA,EAEA,KAAA,GAAAnJ,GAAA,EAAAA,EAAAC,EAAAO,OAAAR,IAEAA,EAAA,IAEAmJ,GAAAuB,GAGAvB,GAAAnF,EAAA/D,EAAAD,QAKAmJ,GAAAnF,EAAA/D,GAEAkJ,IAEAnF,EAAA/D,GAAAkJ,EAAA1J,IAIA,OAAA0J,IAIAyB,QAAA,WAEAlI,KAAAmI,OACAnI,KAAAgB,QAAA,YAKAwB,cAAA,SAAA7D,GAEAjD,EAAAiD,GAEAqB,KAAAoI,mBAAAzJ,EAEA7C,EAAA6C,GAEA,MAAAA,EAAAJ,OAAA,IAEAI,EAAAA,EAAA7B,UAAA,GAEAkD,KAAAoI,mBAAA,SAAA/K,EAAA0B,GAEA,MAAAM,GAAAN,EAAAJ,GAAAtB,EAAAsB,MAKAqB,KAAAoI,mBAAA,SAAA/K,EAAA0B,GAEA,MAAAM,GAAAhC,EAAAsB,GAAAI,EAAAJ,KAMAqB,KAAAoI,mBAAA,MAKAD,KAAA,WAEAnI,KAAAqI,YAEArI,KAAAiC,OAAAkG,KAAAnI,KAAAoI,qBAKAC,SAAA,WAEA,GAAA1J,GAAAqB,KAAAoI,kBAEA,KAAAzJ,EAEA,OAAA,CAKA,KAAA,GAFAsD,GAAAjC,KAAAiC,OAAAU,OAEArF,EAAA,EAAAgL,EAAArG,EAAAnE,OAAA,EAAAwK,EAAAhL,EAAAA,IAEA,GAAAqB,EAAAsD,EAAA3E,GAAA2E,EAAA3E,EAAA,IAAA,EAEA,OAAA,CAIA,QAAA,GAKAiL,cAAA,SAAAC,EAAA/B,EAAAnF,GAEA,GAAAmB,GAAAzC,KACAyG,EAAAA,GAAAhE,EAAAsF,OAAAS,GACAlH,EAAAA,GAAAmB,EAAAR,OAAAwG,IAAAhC,GACAiC,EAAAjG,EAAAkG,OAAA3K,EAAAwK,GAGA,IAAAlH,GAAAA,EAAAsH,OACA,CACA,GAAAC,GAAAvH,EAAAwH,UACAC,KACAC,GAAA,EACAd,IAEA,KAAA,GAAA/K,KAAAqL,GACA,CACA,GAAAS,GAAAJ,EAAA1L,GACA+L,EAAA5H,EAAAsH,OAAAzL,EAEA2B,GAAAmK,EAAAC,IAEA5H,EAAAnE,GAAAuL,EAAAvL,GACA+K,EAAA/K,GAAAmE,EAAA6H,OAAAhM,GAAAqL,EAAArL,KAIA4L,EAAA5L,GAAAqL,EAAArL,GACA6L,GAAA,GAGA1H,EAAAsH,OAAAzL,GAAAa,EAAAwK,EAAArL,IAGA6L,EAEA1H,EAAAN,QAAA,kBAAAwH,EAAAO,IAIAzH,EAAAN,QAAA,eAAAwH,EAAAN,IAGA5G,EAAAN,QAAA,iBAAAwH,IAEAlH,EAAA8H,cAAA/F,OAIA/B,GAAAmB,EAAA4G,YAAAX,GAEApH,EAAA6H,OAAAX,EACAlH,EAAAsH,OAAAtH,EAAA6H,OAAAP,OAAA5K,EAAAwK,GAEAlH,EAAA8H,cAAA/F,EAWA,OARAZ,GAAAR,OAAAqH,IAAA7C,KAEAhE,EAAAR,OAAAuE,IAAAC,EAAAnF,GACAmB,EAAAzB,QAAA,eAAAM,IAEAA,EAAAN,QAAA,UAGAM,GAIAiI,kBAAA,SAAA9C,GAEA,GAAAhE,GAAAzC,KACAsB,EAAAmB,EAAAR,OAAAwG,IAAAhC,EAEA,OAAAnF,GAGAA,EAAAkI,qBAGAlI,GAAAsH,aACAtH,GAAA6H,OAAAP,OAEAnG,EAAAqF,UAAAxG,GACAmB,EAAAqF,UAAAxG,EAAA6H,QAEA7H,EAAAN,QAAA,UAEAM,EAAA8H,cAAA/F,IAEA,IAGA/B,EAAAN,QAAA,iBAEAM,EAAA8H,cAAAlG,GAEAT,EAAAR,OAAA0E,OAAAF,GACAhE,EAAAzB,QAAA,iBAAAM,IAEAA,EAAAN,QAAA,WAEAE,EAAAU,MAAAV,EAAAW,OAAA8B,cAAArC,IAgBA,IAZAmB,EAAAL,MAAAuE,OAAAF,EAAA,SAAAgD,GAEAA,GAEAvI,EAAAU,MAAAV,EAAAW,OAAA8B,cAAA8F,MAKA,IAQA9H,KAAA,WAEA,GAAAc,GAAAzC,IAEAyC,GAAAL,MAAAwE,IAAA,SAAA8C,EAAA9G,GAEA1B,EAAAU,MAAAV,EAAAW,OAAAoC,WAAAyF,GAEAjH,EAAAR,OAAAgB,OAEA,KAAA,GAAA3F,GAAA,EAAAA,EAAAoM,EAAA5L,OAAAR,IACA,CACA,GAAAkL,GAAAkB,EAAApM,GACAmJ,EAAA7D,EAAAtF,GACAoL,EAAAjG,EAAAkG,OAAA3K,EAAAwK,GAAA,IACAlH,EAAAmB,EAAA4G,YAAAX,EAEApH,GAAA6H,OAAAX,EAEAA,EAAAmB,UAEAzI,EAAAU,MAAAV,EAAAW,OAAAqC,oBAAA5C,GAEAA,EAAA8H,cAAAjG,KAIAqF,EAAAI,QAQA1H,EAAAU,MAAAV,EAAAW,OAAAuC,iBAAA9C,GAEAA,EAAA6H,OAAAP,OAAAtH,EAAAsH,SARA1H,EAAAU,MAAAV,EAAAW,OAAAsC,kBAAA7C,GAEAA,EAAA8H,cAAA9F,IASAb,EAAAR,OAAAuE,IAAAC,EAAAnF,IAIAmB,EAAAzB,QAAA,cAEAyB,EAAAyF,UAEAzF,EAAAmH,cAAA,GAEAnH,EAAAoH,aAMAA,QAAA,WAUA,QAAAC,GAAA7H,GAIA,IAAA,GAFA8H,MAEAzM,EAAA,EAAAA,EAAA2E,EAAAnE,OAAAR,IACA,CACA,GAAAgE,GAAAmB,EAAA8F,cAAAtG,EAAA3E,IACAmJ,EAAAnF,EAAA0I,MAEAD,GAAAtD,GAAAnF,EAKA,IAAA,GAFAsB,GAAAH,EAAAR,OAAAW,KAEAtF,EAAA,EAAAA,EAAAsF,EAAA9E,OAAAR,IACA,CACA,GAAAC,GAAAqF,EAAAtF,EAEA,MAAAC,IAAAwM,IACA,CACA,GAAArL,GAAA+D,EAAAR,OAAAwG,IAAAlL,EAEAmB,GAAAkK,SAEA1H,EAAAU,MAAAV,EAAAW,OAAAkC,mBAAAxG,GAEAkF,EAAA8G,kBAAAhM,KAKAkF,EAAAzB,QAAA,eAEAyB,EAAAyF,UAEAhH,EAAAU,MAAAV,EAAAW,OAAA+B,YAAA3B,GAGA,QAAAgI,GAAAhI,EAAAiI,GAEA,IAAAA,GAEAhJ,EAAA0G,qBAEA1G,EAAA6F,SAEAtE,EAAAoF,gBAAA,EAEA3G,EAAAjB,KAAA,SAAA,WAEAiB,EAAAU,MAAAV,EAAAW,OAAAmC,oBAEAvB,EAAAoF,iBAEApF,EAAAoF,gBAAA,EAEApF,EAAAoH,cAKA3I,EAAAU,MAAAV,EAAAW,OAAAgC,sBAIA3C,EAAAU,MAAAV,EAAAW,OAAAiC,kBAAAoG,GAzEA,GAAAzH,GAAAzC,KACAmB,GACAgJ,OAAA,MACAC,IAAA3H,EAAA4H,IAGA5H,GAAAN,KAAAhB,EAAA2I,EAAAG,IA0EAK,UAAA,WAEA,MAAAtK,MAAAiC,OAAAU,QAIA4H,SAAA,SAAA9D,GAEA,GAAApK,EAAAoK,GACA,CAIA,IAAA,GAHAuB,GAAAhI,KAAAiI,cAAA,IACAuC,EAAA,GAEAlN,EAAA,EAAAA,EAAAmJ,EAAA3I,OAAAR,IAEAA,EAAA,IAEAkN,GAAAxC,GAGAwC,GAAA/D,EAAAnJ,EAGAmJ,GAAA+D,EAGA,MAAAxK,MAAAiC,OAAAwG,IAAAhC,IAIAnE,cAAA,SAAAG,GAEA,MAAA,UAAAqE,GAEA,GAAAL,GAAAK,EAAAL,IACA+B,EAAA1B,EAAAxF,KAEA,QAAAwF,EAAA2D,IAEA,IAAA,OAEAhI,EAAA8F,cAAAC,EAAA/B,GACAhE,EAAAyF,UAEAhH,EAAAU,MAAAV,EAAAW,OAAAwC,cAAAyC,EAAAxF,MACA,MAEA,KAAA,SAEAmB,EAAA8G,kBAAA9C,IAEAhE,EAAAyF,UAGAhH,EAAAU,MAAAV,EAAAW,OAAAyC,gBAAAmC,MAOA4C,YAAA,SAAA9F,GAEA,MAAA,IAAAvD,MAAAsB,MAAAiC,IAIAmH,OAAA,SAAAnH,GAEA,MAAAA,IAIAoF,OAAA,SAAAgC,GAEA,MAAAA,IAIAC,KAAA,SAAAtJ,GAEA,GAAAmB,GAAAzC,KACAyG,EAAAnF,EAAA0I,MAGA,OAAA1I,GAAAqI,aAEAzI,GAAAU,MAAAV,EAAAW,OAAAkD,aAAAzD,IAMAmB,EAAAR,OAAAqH,IAAA7C,GAUAhE,EAAAzB,QAAA,iBAAAM,KARAmB,EAAAR,OAAAuE,IAAAC,EAAAnF,GACAmB,EAAAzB,QAAA,eAAAM,IACAmB,EAAAyF,UAEA5G,EAAAN,QAAA,cAQAM,GAAA8H,cAAAhG,KAIAuD,OAAA,SAAArF,GAEA,GAAAmB,GAAAzC,KACAyG,EAAAnF,EAAA0I,MAGAvH,GAAAR,OAAAqH,IAAA7C,KAEAhE,EAAAR,OAAA0E,OAAAF,GACAhE,EAAAzB,QAAA,iBAAAM,IACAmB,EAAAyF,UAEA5G,EAAAN,QAAA,YAIAM,EAAAqI,UAAA,EAIArI,EAAAuJ,eAEA3J,EAAAU,MAAAV,EAAAW,OAAAgE,mBAAAvE,GAEAA,EAAAuJ,cAAA,GAIAvJ,EAAA8H,cAAApG,KAKAzD,EAAA8B,EAAAI,WCtgBAC,EAAAD,WAGAqJ,MAAA,SAAAnN,GAEAqC,KAAA6K,cAAA,EACA7K,KAAA+K,WAAA,KACA/K,KAAAgL,cAEAhL,KAAAiL,OAAAtN,IAGAsN,OAAA,SAAAtN,GAEA,GAAAuN,GAAAlL,KAAA0C,IAAAyI,SACAC,EAAApL,KAAA0C,IAAA0I,MAEA,IAAA7O,EAAA2O,GAEA,IAAA,GAAA5N,GAAA,EAAAA,EAAA8N,EAAAtN,OAAAR,IACA,CACA,GAAAH,GAAAiO,EAAA9N,EAEA,IAAAH,IAAA+N,GACA,CACA,GAAAG,GAAAH,EAAA/N,EAEAzB,GAAA2P,GAEArL,KAAA7C,GAAAkO,IAIArL,KAAA7C,GAAAa,EAAAqN,OAKArL,MAAA7C,GAAA5B,MAMA,KAAA,GAAA+B,GAAA,EAAAA,EAAA8N,EAAAtN,OAAAR,IACA,CACA,GAAAH,GAAAiO,EAAA9N,EAEA0C,MAAA7C,GAAA5B,EAIAyE,KAAAsL,KAAA3N,IAGA2N,KAAA,SAAA3N,EAAA4N,GAEA,GAAAhP,EAAAoB,GAEAX,EAAAW,EAAAqC,UAEA,IAAAlE,EAAA6B,IAAA,SAAA4N,EAEA,GAAA5N,IAAAqC,MAAAgL,WACA,CACA,GAAAQ,GAAAxL,KAAA0C,IAAAH,UAAA5E,EAEA6N,GAAAC,IAAAzL,KAAAuL,OAIAvL,MAAArC,GAAA4N,GAKAG,KAAA,SAAA/N,EAAAC,GAEA,GAAAvB,EAAAsB,GAEA,MAAAF,GAAAuC,KAAArC,EAAAC,EAEA,IAAArB,EAAAoB,GACA,CACA,IAAA,GAAAI,KAAAJ,GAEAA,EAAAI,GAAAH,EAAAI,EAAAgC,KAAAjC,IAAAiC,KAAAjC,EAGA,OAAAJ,GAEA,GAAA7B,EAAA6B,GACA,CACA,GAAAA,IAAAqC,MAAAgL,WACA,CACA,GAAAQ,GAAAxL,KAAA0C,IAAAH,UAAA5E,GACAgF,EAAA6I,EAAA/C,IAAAzI,KAEA,OAAApC,GAAAI,EAAA2E,GAAAA,EAIA,MAAA/E,GAAAI,EAAAgC,KAAArC,IAAAqC,KAAArC,KAKAgO,MAAA,SAAAC,EAAAC,GAIA,MAFA7L,MAAAsL,KAAAM,EAAAC,GAEA7L,KAAA0C,IAAAkI,KAAA5K,OAGA8L,QAAA,WAEA,MAAA9L,MAAA0C,IAAAiE,OAAA3G,OAGAoJ,cAAA,SAAA2C,GAEA,GAAAC,GAAA,GAAAD,GAAA/L,KAEAA,MAAA+K,WAOA/K,KAAA+K,WAAAkB,MAAAD,IALAhM,KAAA+K,WAAAiB,EACAhM,KAAA+K,WAAAmB,YAQApD,QAAA,WAEA,MAAA9I,MAAA0C,IAAAgI,OAAAjN,EAAAuC,KAAAA,KAAA0C,IAAA0I,QAAA,KAGApB,KAAA,WAEA,MAAAhK,MAAA0C,IAAAqF,OAAA/H,OAGAmM,SAAA,WAEA,QAAAnM,KAAA4I,QAGAwD,gBAAA,WAEA,QAAApM,KAAAmJ,QAGAkD,YAAA,WAEA,GAAAC,GAAAtM,KAAA4I,OACAJ,EAAAxI,KAAA8I,UACAsC,EAAApL,KAAA0C,IAAA0I,MAEA,OAAAkB,GAAA9N,EAAAgK,EAAA8D,EAAAlB,EAAAtM,GAAA0J,GAGAgB,YAAA,WAEA,IAAAxJ,KAAA4I,OAEA,OAAA,CAGA,IAAAJ,GAAAxI,KAAA8I,UACAwD,EAAAtM,KAAA4I,MAEA,KAAA,GAAAzL,KAAAqL,GACA,CACA,GAAAS,GAAAT,EAAArL,GACA+L,EAAAoD,EAAAnP,EAEA,KAAA2B,EAAAmK,EAAAC,GAEA,OAAA,EAIA,OAAA,IAKA3J,EAAAmC,EAAAD,WCpMAS,EAAAT,WASAwB,MAAA,WAMA,MAJAjD,MAAA2C,OAAA7E,OAAA,EACAkC,KAAA4C,KAAA9E,OAAA,EACAkC,KAAA6C,WAEA7C,MAWAwG,IAAA,SAAAC,EAAA8E,GAaA,MAXA9E,KAAAzG,MAAA6C,QAEA7C,KAAA2C,OAAA3C,KAAA6C,QAAA4D,IAAA8E,GAIAvL,KAAA6C,QAAA4D,GAAAzG,KAAA2C,OAAA7E,OACAkC,KAAA2C,OAAAxE,KAAAoN,GACAvL,KAAA4C,KAAAzE,KAAAsI,IAGAzG,MASAyI,IAAA,SAAAhC,GAEA,MAAAzG,MAAA2C,OAAA3C,KAAA6C,QAAA4D,KAUAE,OAAA,SAAAF,GAEA,GAAA8F,GAAAvM,KAAA6C,QAAA4D,EAOA,OALA1K,GAAAwQ,IAEAvM,KAAAwM,SAAAD,GAGAvM,MAUAwM,SAAA,SAAAD,GAEA,GAAA9F,GAAAzG,KAAA4C,KAAA2J,GACAE,EAAAzM,KAAA2C,OAAA+J,MACAC,EAAA3M,KAAA4C,KAAA8J,KAWA,OATAH,GAAAvM,KAAA2C,OAAA7E,SAEAkC,KAAA2C,OAAA4J,GAAAE,EACAzM,KAAA4C,KAAA2J,GAAAI,EACA3M,KAAA6C,QAAA8J,GAAAJ,SAGAvM,MAAA6C,QAAA4D,GAEAzG,MASAsJ,IAAA,SAAA7C,GAEA,MAAAA,KAAAzG,MAAA6C,SAQA+J,KAAA,WAEA,MAAA5M,MAAA2C,OAAA7E,QAWA+O,OAAA,SAAAhN,EAAAiN,GAOA,IAAA,GALAC,GAAAD,GAAA,GAAA5K,GACAoG,EAAAtI,KAAA4M,OACAjK,EAAA3C,KAAA2C,OACAC,EAAA5C,KAAA4C,KAEAtF,EAAA,EAAAgL,EAAAhL,EAAAA,IACA,CACA,GAAA0P,GAAArK,EAAArF,GACAC,EAAAqF,EAAAtF,EAEAuC,GAAAmN,EAAAzP,IAEAwP,EAAAvG,IAAAjJ,EAAAyP,GAIA,MAAAD,IASAE,QAAA,WAKA,IAAA,GAHAnM,GAAAd,KAAA4M,OAAA,EACAM,EAAAvQ,KAAAwQ,KAAArM,EAAA,GAEAxD,EAAA,EAAA4P,EAAA5P,EAAAA,IAEAF,EAAA4C,KAAA2C,OAAArF,EAAAwD,EAAAxD,GACAF,EAAA4C,KAAA4C,KAAAtF,EAAAwD,EAAAxD,EAKA,OAFA0C,MAAAoN,eAEApN,MAeAmI,KAAA,SAAAxJ,GAKA,QAAA0O,GAAAC,EAAAC,GAMA,IAJA,GAAAC,GAAAC,EAAA9K,OAAAhG,KAAA+Q,OAAAH,EAAAD,GAAA,IACAhQ,EAAAgQ,EACAK,EAAAJ,EAEAI,GAAArQ,GACA,CACA,KAAAqB,EAAA8O,EAAA9K,OAAArF,GAAAkQ,GAAA,GAAAlQ,GACA,MAAAqB,EAAA8O,EAAA9K,OAAAgL,GAAAH,GAAA,GAAAG,GAEAA,IAAArQ,IACAF,EAAAqQ,EAAA9K,OAAArF,EAAAqQ,GACAvQ,EAAAqQ,EAAA7K,KAAAtF,EAAAqQ,GACArQ,IACAqQ,KAIA,MAAArQ,GAIA,QAAAsQ,GAAAN,EAAAC,GAEA,GAAAhB,GAAAc,EAAAC,EAAAC,EAEAhB,GAAA,EAAAe,GAEAM,EAAAN,EAAAf,EAAA,GAGAgB,EAAAhB,GAEAqB,EAAArB,EAAAgB,GArCA,GAAAE,GAAAzN,KAyCAuN,EAAAvN,KAAA4M,OAAA,CAUA,OAPAW,GAAA,IAEAK,EAAA,EAAAL,GAEAvN,KAAAoN,gBAGApN,MASAoN,aAAA,WAEApN,KAAA6C,UAEA,KAAA,GAAAvF,GAAA,EAAAuQ,EAAA7N,KAAA4C,KAAA9E,OAAA+P,EAAAvQ,EAAAA,IAEA0C,KAAA6C,QAAA7C,KAAA4C,KAAAtF,IAAAA,CAGA,OAAA0C,QCpRA8C,EAAArB,WAEAwB,MAAA,SAAA3B,GAEAtB,KAAAsB,MAAAA,EACAtB,KAAAyC,GAAAnB,EAAAoB,IACA1C,KAAA8N,KAAA,KACA9N,KAAA+N,UAAA,GAGA9B,MAAA,SAAAD,GAEAhM,KAAA8N,OAAA9B,EAAAjJ,WAEA/C,KAAA8N,KAAA7B,MAAAD,GAIAhM,KAAA8N,KAAA9B,GAIAE,QAAA,WAEAlM,KAAAgO,IAAAhO,KAAAyC,GAAAzC,KAAAsB,QAGA0M,IAAA,SAAAvL,EAAAnB,GAEA,KAAA,sCAGA2M,OAAA,WAYA,MAVAjO,MAAA+N,WAEA/N,KAAA+N,UAAA,GAEA/N,KAAAsB,MAAAyJ,WAAA/K,KAAA8N,OAEA9N,KAAA8N,KAAA5B,WAIAlM,MAGAkO,QAAA,SAAAnC,GAEA/L,KAAA8N,OAEA9N,KAAA8N,KAAA,GAAA/B,GAAA/L,KAAAsB,SAIA6M,WAAA,SAAApC,GAEA,GAAAtB,GAAA,GAAAsB,GAAA/L,KAAAsB,MAEAmJ,GAAAqD,KAAA9N,KAAA8N,KACA9N,KAAA8N,KAAArD,GAGAnE,QAAA,WAEA,GAAAmE,GAAAzK,IAEA,OAAA,YAEAyK,EAAA2D,UAAAvS,MAAA4O,EAAA4D,WACA5D,EAAAwD,WAIAG,UAAA,aAKA7H,QAAA,WAEA,GAAAkE,GAAAzK,IAEA,OAAA,YAEAyK,EAAA6D,UAAAzS,MAAA4O,EAAA4D,WACA5D,EAAAwD,WAIAK,UAAA,cC3FAtL,EAAAvB,UAAA,GAAAqB,IAAA,GAEAE,EAAAvB,UAAAuM,IAAA,SAAAvL,EAAAnB,GAEA,GAAAmF,GAAAnF,EAAA0I,MAGA,OAAA1I,GAAA6H,YAQA7H,EAAAsH,QAGAtH,EAAA6H,OAAAQ,UAAA,EAEAlH,EAAAL,MAAAoE,IAAAC,EAAAnF,EAAA6H,OAAAnJ,KAAAsG,UAAAtG,KAAAuG,aAIArF,EAAAU,MAAAV,EAAAW,OAAAoE,qBAAA3E,GAEAmB,EAAAL,MAAAuE,OAAAF,EAAAzG,KAAAsG,UAAAtG,KAAAuG,cAjBArF,EAAAU,MAAAV,EAAAW,OAAAmE,kBAAA1E,GAEAtB,KAAAiO,WAmBAjL,EAAAvB,UAAA2M,UAAA,SAAA3H,EAAA+B,EAAA+F,GAEA,GAAAjN,GAAAtB,KAAAsB,KAEAJ,GAAAU,MAAAV,EAAAW,OAAA0D,aAAAjE,GAEAA,EAAAsH,QAEAtH,EAAA8H,cAAAjG,IAIAH,EAAAvB,UAAA6M,UAAA,SAAArN,GAEA,GAAAK,GAAAtB,KAAAsB,KAEAJ,GAAAU,MAAAV,EAAAW,OAAAiE,mBAAAxE,EAAAL,GAEAK,EAAAsH,QAEAtH,EAAA8H,cAAAjG,IClDAD,EAAAzB,UAAA,GAAAqB,IAAA,GAEAI,EAAAzB,UAAAuM,IAAA,SAAAvL,EAAAnB,GAEA,GAAAmF,GAAAnF,EAAA0I,MAEAvH,GAAAR,OAAAqH,IAAA7C,KAEAhE,EAAAR,OAAA0E,OAAAF,GACAhE,EAAAzB,QAAA,iBAAAM,IACAmB,EAAAyF,UAEA5G,EAAAN,QAAA,YAGAyB,EAAAL,MAAAuE,OAAAF,EAAAzG,KAAAsG,UAAAtG,KAAAuG,YCfApD,EAAA1B,UAAA,GAAAqB,IAAA,GAEAK,EAAA1B,UAAAuM,IAAA,SAAAvL,EAAAnB,GAGAA,EAAAuJ,cAAA,EACAvJ,EAAAqI,UAAA,EAGA3J,KAAAyG,IAAAnF,EAAA0I,MAGA,IAAA7I,IACAgJ,OAAA,SACAC,IAAA3H,EAAA4H,IAAArK,KAAAyG,IAGAhE,GAAAN,KAAAhB,EAAAnB,KAAAsG,UAAAtG,KAAAuG,YAGApD,EAAA1B,UAAA2M,UAAA,SAAA7K,GAEAvD,KAAAwO,gBAGArL,EAAA1B,UAAA6M,UAAA,SAAA/K,EAAA2G,GAEA,GAAAzD,GAAAzG,KAAAyG,IACAnF,EAAAtB,KAAAsB,KAEA,OAAA4I,GAAA,MAAAA,GAEAhJ,EAAAU,MAAAV,EAAAW,OAAA2D,eAAAiB,EAAAnF,GAEAtB,KAAAwO,gBAEA,IAAAtE,EAEAhJ,EAAAU,MAAAV,EAAAW,OAAA4D,aAAAyE,EAAAzD,EAAAnF,IAKAJ,EAAA0G,qBAGA1G,EAAA6F,QAEA7F,EAAAjB,KAAA,SAAA,WAEAiB,EAAAU,MAAAV,EAAAW,OAAA8D,cAAArE,GAEAA,EAAA8H,cAAAjG,KAIAjC,EAAAU,MAAAV,EAAAW,OAAA6D,eAAApE,KAIA6B,EAAA1B,UAAA+M,aAAA,WAEA,GAAA/L,GAAAzC,KAAAyC,GACAgE,EAAAzG,KAAAyG,IACAnF,EAAAtB,KAAAsB,KAEAJ,GAAAU,MAAAV,EAAAW,OAAA+D,cAAAa,EAAAnF,GAGAtB,KAAAmO,WAAAjL,GAGAhC,EAAAU,MAAAV,EAAAW,OAAAyD,eAAAmB,EAAAnF,GAEAmB,EAAAJ,MACAoI,GAAA,SACAhE,IAAAA,KC5EArD,EAAA3B,UAAA,GAAAqB,IAAA,GAEAM,EAAA3B,UAAAuM,IAAA,SAAAvL,EAAAnB,GAGA,GAAAA,EAAAqI,SAIA,MAFAzI,GAAAU,MAAAV,EAAAW,OAAAqD,mBAAA5D,GAEAtB,KAAAiO,QAGA,IAAAzF,GAAAlH,EAAAwH,SAGAxH,GAAA6H,OAOAnM,EAAAwL,EAAAlH,EAAA6H,QALA7H,EAAA6H,OAAAX,EAQA/F,EAAAL,MAAAoE,IAAAlF,EAAA0I,OAAA1I,EAAA6H,OAAAnJ,KAAAsG,UAAAtG,KAAAuG,YAGAnD,EAAA3B,UAAA2M,UAAA,SAAA3H,EAAA+B,EAAA+F,GAEA,GAAAjN,GAAAtB,KAAAsB,KAEAJ,GAAAU,MAAAV,EAAAW,OAAAmD,WAAA1D,GAEAtB,KAAAkO,QAAA5K,IAGAF,EAAA3B,UAAA6M,UAAA,SAAArN,GAEA,GAAAK,GAAAtB,KAAAsB,KAEAJ,GAAAU,MAAAV,EAAAW,OAAAoD,iBAAA3D,EAAAL,GAEAjB,KAAAkO,QAAA5K,IC3CAD,EAAA5B,UAAA,GAAAqB,IAAA,GAEAO,EAAA5B,UAAAuM,IAAA,SAAAvL,EAAAnB,GAEAmB,EAAAL,MAAAoE,IAAAlF,EAAA0I,OAAA1I,EAAA6H,OAAAnJ,KAAAsG,UAAAtG,KAAAuG,YCJAjD,EAAA7B,UAAA,GAAAqB,IAAA,GAEAQ,EAAA7B,UAAAuM,IAAA,SAAAvL,EAAAnB,GAGA,GAAAA,EAAAqI,SAIA,MAFAzI,GAAAU,MAAAV,EAAAW,OAAAuD,oBAAA9D,GAEAtB,KAAAiO,QAIA,IAAAxH,GAAAzG,KAAAyG,IAAAnF,EAAA0I,OAGAyE,EAAAzO,KAAAyO,OAAAnN,EAAA+K,aAGA,IAAAxN,EAAA4P,GAEA,MAAAzO,MAAAiO,QAIA,IAAA9M,IACAgJ,OAAA7I,EAAAsH,OAAA,MAAA,OACAwB,IAAA9I,EAAAsH,OAAAnG,EAAA4H,IAAA5D,EAAAhE,EAAA4H,IACA9G,KAAAkL,EAGAhM,GAAAN,KAAAhB,EAAAnB,KAAAsG,UAAAtG,KAAAuG,YAGAjD,EAAA7B,UAAA2M,UAAA,SAAA7K,GAEA,GAAAjC,GAAAtB,KAAAsB,KAEAJ,GAAAU,MAAAV,EAAAW,OAAAiD,YAAAxD,GAEAtB,KAAA0O,WAAAnL,IAGAD,EAAA7B,UAAA6M,UAAA,SAAA/K,EAAA2G,GAEA,GACA5I,IADAtB,KAAAyC,GACAzC,KAAAsB,MAGA,OAAA4I,GAEAhJ,EAAAU,MAAAV,EAAAW,OAAA4C,cAAAlB,EAAAjC,GAGAtB,KAAA0O,WAAAnL,EAAAjC,EAAAtB,KAAAyC,KAEA,MAAAyH,GAAA,MAAAA,GAEAhJ,EAAAU,MAAAV,EAAAW,OAAA6C,iBAAApD,GAEAtB,KAAAmO,WAAAjL,IAEA,IAAAgH,EAEAhJ,EAAAU,MAAAV,EAAAW,OAAA8C,WAAArD,EAAA4I,IAKAhJ,EAAA0G,qBAGA1G,EAAA6F,SAEAzF,EAAAuJ,cAAA,EAEA3J,EAAAjB,KAAA,SAAA,WAEAqB,EAAAuJ,eAEAvJ,EAAAuJ,cAAA,EACAvJ,EAAA8H,cAAA9F,GAEApC,EAAAU,MAAAV,EAAAW,OAAAgD,YAAAvD,OAKAJ,EAAAU,MAAAV,EAAAW,OAAA+C,aAAAtD,KAIAgC,EAAA7B,UAAAiN,WAAA,SAAAnL,GAEA,GAAAd,GAAAzC,KAAAyC,GACAnB,EAAAtB,KAAAsB,MACAmN,EAAAzO,KAAAyO,MAGA,IAAAnN,EAAAqI,SAIA,WAFAzI,GAAAU,MAAAV,EAAAW,OAAAuD,oBAAA9D,EAAAiC,EAMA,KAAA,GAAApG,KAAAoG,GAEApG,IAAAsR,KAEAA,EAAAtR,GAAAoG,EAAApG,GAIA+D,GAAAU,MAAAV,EAAAW,OAAA0C,YAAAkK,EAAAnN,GAIAA,EAAAsH,SAEAtH,EAAAsH,OAAAtH,EAAA6H,OAAAP,WAIAnG,EAAA8F,cAAAkG,EAAAzO,KAAAyG,IAAAnF,GAGAJ,EAAAU,MAAAV,EAAAW,OAAA2C,aAAAiK,EAAAnN,GAEAmB,EAAAJ,MACAoI,GAAA,OACAnJ,MAAAmN,EACAhI,IAAAzG,KAAAyG,OMzIAnL,EAAA4F,MAAAA,GAEA8F","file":"neurosync.min.js","sourcesContent":["(function(global, undefined)\n{\n","\n\nfunction isDefined(x)\n{\n  return typeof x !== 'undefined';\n}\n\nfunction isFunction(x)\n{\n  return !!(x && x.constructor && x.call && x.apply);\n}\n\nfunction isString(x)\n{\n  return typeof x === 'string';\n}\n\nfunction isNumber(x)\n{\n  return typeof x === 'number' && !isNaN(x);\n}\n\nfunction isDate(x)\n{\n  return x instanceof Date;\n}\n\nfunction isRegExp(x)\n{\n  return x instanceof RegExp;\n}\n\nfunction isArray(x)\n{\n  return x instanceof Array;\n}\n\nfunction isObject(x)\n{\n  return x !== null && typeof x === 'object';\n}\n\nfunction toArray(x, split)\n{\n  return x instanceof Array ? x : x.split( split );\n}\n\nfunction indexOf(arr, x, comparator)\n{\n  var cmp = comparator || equalsStrict;\n\n  for (var i = 0, n = arr.length; i < n; i++)\n  {\n    if ( cmp( arr[i], x ) )\n    {\n      return i;\n    }\n  }\n\n  return false;\n}\n\nfunction S4() \n{\n  return (((1+Math.random())*0x10000)|0).toString(16).substring(1);\n}\n\nfunction uuid() \n{\n    return (S4()+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+S4()+S4());\n}\n\nfunction extend(parent, child, override)\n{\n  child.prototype = parent;\n\n  for (var prop in override)\n  {\n    child.prototype[ prop ] = override[ prop ];\n  }\n}\n\nfunction propsMatch(test, testFields, expected, expectedFields)\n{\n  if ( isString( testFields ) ) // && isString( expectedFields )\n  {\n    return test[ testFields ] === expected[ expectedFields ];\n  }\n  else // if ( isArray( testFields ) && isArray( expectedFields ) )\n  {\n    for (var i = 0; i < testFields.length; i++)\n    {\n      var testProp = testFields[ i ];\n      var expectedProp = expectedFields[ i ];\n\n      if ( test[ testProp ] !== expected[ expectedProp ] )\n      {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction transfer(from, to)\n{\n  for (var prop in from)\n  {\n    to[ prop ] = from[ prop ];\n  }\n\n  return to;\n}\n\nfunction swap(a, i, k)\n{\n  var t = a[ i ];\n  a[ i ] = a[ k ];\n  a[ k ] = t;\n}\n\nfunction grab(obj, props, copyValues)\n{\n  var grabbed = {};\n\n  for (var i = 0; i < props.length; i++) \n  {\n    var p = props[ i ];\n\n    if ( p in obj ) \n    {\n      grabbed[ p ] = copyValues ? copy( obj[ p ] ) : obj[ p ];\n    }\n  }\n\n  return grabbed;\n}\n\nfunction copy(x, copyHidden)\n{\n  if (x === void 0)\n  {\n    return x;\n  }\n  if (isArray(x)) \n  {\n    var c = [];\n\n    for (var i = 0; i < x.length; i++) \n    {\n      c.push( copy(x[i]) );\n    }\n    return x;\n  }\n  if (isFunction(x) || typeof x !== 'object' || x === null)\n  {\n    return x;\n  }\n  if (isDate(x))\n  {\n    return new Date( x.getTime() );\n  }\n  if (isRegExp(x))\n  {\n    return new RegExp( x.source, x.toString().match(/[^\\/]*$/)[0] );\n  }\n\n  var c = {};\n\n  for (var prop in x) \n  {\n    if (copyHidden || prop.charAt(0) !== '$')\n    {\n      c[ prop ] = copy( x[prop] );\n    }\n  }\n\n  return c;\n}\n\nfunction diff(curr, old, props, comparator)\n{\n  var d = {};\n\n  for (var i = 0; i < props.length; i++)\n  {\n    var p = props[ i ];\n\n    if (p in curr && p in old && !comparator( curr[ p ], old[ p ] ) )\n    {\n      d[ p ] = copy( curr[ p ] );\n    }\n  }\n\n  return d;\n}\n\nfunction isEmpty(x)\n{\n  if (x === null || x === void 0 || x === 0) \n  {\n    return true;\n  }\n  if (isArray(x)) \n  {\n    return x.length === 0;\n  }\n  if (isDate(x)) \n  {\n    return x.getTime() === 0 || isNaN( x.getTime() );\n  }\n  if (isObject(x)) \n  {\n    for (var prop in x) \n    {\n      return false;\n    }\n    return true;\n  }\n\n  return false;\n}\n\nfunction equalsStrict(a, b)\n{\n  return a === b;\n}\n\nfunction equals(a, b)\n{\n  if (a === b) return true;\n  if (a === null || b === null) return false;\n  if (a !== a && b !== b) return true; // NaN === NaN\n\n  var at = typeof a;\n  var bt = typeof b;\n  if (at !== bt) return false;\n\n  var aa = isArray(a);\n  var ba = isArray(b);\n  if (aa !== ba) return false;\n\n  if (aa) {\n    if (a.length !== b.length) return false;\n    for (var i = 0; i < a.length; i++) {\n      if (!equals(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if (isDate(a)) {\n    return isDate(b) && equals( a.getTime(), b.getTime() );\n  }\n  if (isRegExp(a)) {\n    return isRegExp(b) && a.toString() === b.toString();\n  }\n\n  if (at === 'object') {\n    for (var p in a) {\n      if (p.charAt(0) !== '$' || !isFunction(a[p])) {\n        if (!(p in b) || !equals(a[p], b[p])) {\n          return false;\n        }\n      }\n    }\n    for (var p in b) {\n      if (p.charAt(0) !== '$' || !isFunction(b[p])) {\n        if (!(p in a)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  return false;\n}\n\nfunction compareNumbers(a, b) \n{\n  return (a === b ? 0 : (a < b ? -1 : 1));\n}\n\nfunction compare(a, b)\n{\n  if (a == b) \n  {\n    return 0;\n  }\n  if (isDate(a)) \n  {\n    a = a.getTime();\n  }\n  if (isDate(b)) \n  {\n    b = b.getTime();\n  }\n  if (isNumber(a) && isNumber(b)) \n  {\n    return compareNumbers(a, b);\n  }\n  if (isArray(a) && isArray(b)) \n  {\n    return compareNumbers(a.length, b.length);\n  }\n  \n  return (a + '').localeCompare(b + '');\n}\n","\n/**\n * Adds functions to the given object (or prototype) so you can listen for any \n * number of events on the given object, optionally once. Listeners can be \n * removed later.\n *\n * The following methods will be added to the given target:\n *\n *     target.on( events, callback, [context] )\n *     target.once( events, callback, [context] )\n *     target.off( events, callback )\n *     target.trigger( event, [argument] )\n *\n * Where... \n * - `events` is a string of space delimited events.\n * - `callback` is a function to invoke when the event is triggered.\n * - `context` is an object that should be the `this` when the callback is \n *   invoked. If no context is given the default value is the object which has \n *   the trigger function that was invoked.\n *\n * @method eventize\n * @for Core\n * @param {Object} target The object to add `on`, `once`, `off`, and `trigger` \n *    functions to.\n */\nfunction eventize(target)\n{\n  /**\n   * **See:** {{#crossLink \"Core/eventize:method\"}}{{/crossLink}}\n   * \n   * @class eventize\n   */\n\n  // Adds a listener to $this\n  var onListeners = function($this, property, events, callback, context)\n  {\n    var events = toArray( events, ' ' );\n    \n    if ( !isDefined( $this[ property ] ) )\n    {\n      $this[ property ] = {};\n    }\n    \n    for (var i = 0; i < events.length; i++)\n    {\n      if ( !isDefined( $this[ property ][ events[i] ] ) )\n      {\n        $this[ property ][ events[i] ] = [];\n      }\n      \n      $this[ property ][ events[i] ].push( [ callback, context || $this ] );\n    }\n  };\n  \n  /**\n   * Listens for every occurrence of the given events and invokes the callback\n   * each time any of them are triggered.\n   * \n   * @method on\n   * @for eventize\n   * @param {String|Array|Object} events\n   * @param {Function} callback\n   * @param {Object} [context]\n   * @chainable\n   */\n  target.on = function(events, callback, context)\n  {\n    onListeners( this, '$on', events, callback, context );\n\n    return this;\n  };\n  \n  /**\n   * Listens for the next occurrence for each of the given events and invokes\n   * the callback when any of the events are triggered.\n   * \n   * @method once\n   * @for eventize\n   * @param {String|Array|Object} events\n   * @param {Function} callback\n   * @param {Object} [context]\n   * @chainable\n   */\n  target.once = function(events, callback, context)\n  {\n    onListeners( this, '$once', events, callback, context );\n\n    return this;\n  };\n  \n  // Removes a listener from an array of listeners.\n  var offListeners = function(listeners, event, callback)\n  {\n    if (listeners && event in listeners)\n    {\n      var eventListeners = listeners[ event ];\n      \n      for (var k = eventListeners.length - 1; k >= 0; k--)\n      {\n        if (eventListeners[ k ][0] === callback)\n        {\n          eventListeners.splice( k, 1 );\n        }\n      }  \n    }\n  };\n\n  // Deletes a property from the given object if it exists\n  var deleteProperty = function(obj, prop)\n  {\n    if ( obj && prop in obj )\n    {\n      delete obj[ prop ];\n    }\n  };\n  \n  /**\n   * Stops listening for a given callback for a given set of events.\n   *\n   * **Examples:**\n   *\n   *     target.off();           // remove all listeners\n   *     target.off('a b');      // remove all listeners on events a & b\n   *     target.off(['a', 'b']); // remove all listeners on events a & b\n   *     target.off('a', x);     // remove listener x from event a\n   * \n   * @method off\n   * @for eventize\n   * @param {String|Array|Object} [events]\n   * @param {Function} [callback]\n   * @chainable\n   */\n  target.off = function(events, callback)\n  {\n    // Remove ALL listeners\n    if ( !isDefined( events ) )\n    {\n      deleteProperty( this, '$on' );\n      deleteProperty( this, '$once' );\n    }\n    else\n    {\n      var events = toArray( events, ' ' );\n\n      // Remove listeners for given events\n      if ( !isFunction( callback ) )\n      {\n        for (var i = 0; i < events.length; i++)\n        {\n          deleteProperty( this.$on, events[i] );\n          deleteProperty( this.$once, events[i] );\n        }\n      }\n      // Remove specific listener\n      else\n      {\n        for (var i = 0; i < events.length; i++)\n        {\n          offListeners( this.$on, events[i], callback );\n          offListeners( this.$once, events[i], callback );\n        }\n      }\n    }\n\n    return this;\n  };\n  \n  // Triggers listeneers for the given event\n  var triggerListeners = function(listeners, event, args, clear)\n  {\n    if (listeners && event in listeners)\n    {\n      var eventListeners = listeners[ event ];\n      var max = eventListeners.length;\n     \n      for (var i = 0; i < max; i++)\n      {\n        var callback = eventListeners[ i ];\n        \n        callback[0].apply( callback[1], args );\n      }\n      \n      if ( clear )\n      {\n        if ( eventListeners.length !== max )\n        {\n          listeners[ event ] = eventListeners.slice( max );  \n        }\n        else\n        {\n          delete listeners[ event ];  \n        }\n      }\n    }\n  };\n  \n  /**\n   * Triggers a single event optionally passing an argument to any listeners.\n   * \n   * @method trigger\n   * @for eventize\n   * @param {String} event\n   * @param {Array} args\n   * @chainable\n   */\n  target.trigger = function(events, args)\n  {\n    var events = toArray( events, ' ' );\n\n    for (var i = 0; i < events.length; i++)\n    {\n      var e = events[ i ];\n\n      triggerListeners( this.$on, e, args, false );\n      triggerListeners( this.$once, e, args, true );\n    }\n\n    return this;\n  };\n};","\n/*\nnew Neuro({\n  name: 'name',\n  api: 'http://api/name',\n  pubsub: 'http://url:port',\n  channel: 'houseid',\n  token: 'userid',\n  key: 'id',\n  fields: ['id', 'name', 'updated_at'],\n//  encode: function() {},\n//  decode: function() {}\n});\n*/\n\nfunction Neuro(options)\n{\n  var database = new NeuroDatabase( options );\n\n  var model = new Function('return function ' + options.className + '(props) { this.$init( props ) }')();\n\n  model.prototype = new NeuroModel( database );\n\n  database.model = model;\n  database.init();\n\n  Neuro.debug( Neuro.Events.CREATION, options, database );\n\n  return {\n    Database: database, \n    Model: model\n  };\n}\n\neventize( Neuro );\n","\n\nfunction NeuroDatabase(options)\n{  \n  transfer( options, this );\n\n  this.models = new NeuroMap();\n\n  this.rest = Neuro.rest( this );\n  this.store = Neuro.store( this );\n  this.live = Neuro.live( this, this.handlePublish( this ) );\n\n  this.relations = {};\n\n  this.setComparator( this.comparator );\n}\n\nNeuroDatabase.prototype =\n{\n\n  // Whether or not there's a load pending until we're online again\n  pendingRefresh: false,\n\n  // Removes the key from the given model\n  removeKey: function(model)\n  {\n    var k = this.key;\n\n    if ( isArray(k) )\n    {\n      for (var i = 0; i < k.length; i++) \n      {\n        delete model[ k[i] ];\n      }\n    }\n    else\n    {\n      delete model[ k ];\n    }\n  },\n\n  // Gets the key from the given model\n  getKey: function(model)\n  {\n    var k = this.key;\n    var key = null;\n\n    if ( isArray(k) )\n    {\n      var ks = this.keySeparator || '/';\n      \n      key = '';\n      \n      for (var i = 0; i < k.length; i++) \n      {\n        if (i > 0) \n        {\n          key += ks;\n        }\n\n        key += model[ k[i] ];\n      }\n    }\n    else\n    {\n      key = model[ k ];\n\n      if (!key)\n      {\n        model[ k ] = key = uuid();\n      }\n    }\n\n    return key;\n  },\n\n  // Sorts the models & notifies listeners that the database has been updated.\n  updated: function()\n  {\n    this.sort();\n    this.trigger( 'updated' );\n  },\n\n  // Sets a comparator for this database. It can be a field name, a field name\n  // with a minus in the front to sort in reverse, or a comparator function.\n  setComparator: function(comparator)\n  {\n    if ( isFunction( comparator ) )\n    {\n      this.comparatorFunction = comparator;\n    }\n    else if ( isString( comparator ) )\n    {\n      if ( comparator.charAt(0) === '-' )\n      {\n        comparator = comparator.substring( 1 );\n\n        this.comparatorFunction = function(a, b)\n        {\n          return compare( b[ comparator ], a[ comparator ] );\n        };\n      }\n      else\n      {\n        this.comparatorFunction = function(a, b)\n        {\n          return compare( a[ comparator ], b[ comparator ] );\n        };\n      }\n    }\n    else\n    {\n      this.comparatorFunction = null;\n    }\n  },\n\n  // Sorts the database if it isn't sorted.\n  sort: function()\n  {\n    if ( !this.isSorted() )\n    {\n      this.models.sort( this.comparatorFunction );\n    }\n  },\n\n  // Determines whether this database is sorted.\n  isSorted: function()\n  {\n    var comparator = this.comparatorFunction;\n\n    if ( !comparator )\n    {\n      return true;\n    }\n\n    var models = this.models.values;\n\n    for (var i = 0, n = models.length - 1; i < n; i++)\n    {\n      if ( comparator( models[ i ], models[ i + 1 ] ) > 0 )\n      {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  // Handles when we receive data from the server - either from\n  // a publish, refresh, or values being returned on a save.\n  putRemoteData: function(encoded, key, model)\n  {\n    var db = this;\n    var key = key || db.getKey( encoded );\n    var model = model || db.models.get( key );\n    var decoded = db.decode( copy( encoded ) );\n    var hasModel = !!model;\n\n    if ( model && model.$saved )\n    {\n      var current = model.$toJSON();\n      var conflicts = {};\n      var conflicted = false;\n      var updated = {};\n\n      for (var prop in encoded)\n      {\n        var currentValue = current[ prop ];\n        var savedValue = model.$saved[ prop ];\n\n        if ( equals( currentValue, savedValue ) )\n        {\n          model[ prop ] = decoded[ prop ];\n          updated[ prop ] = model.$local[ prop ] = encoded[ prop ];\n        }\n        else\n        {\n          conflicts[ prop ] = encoded[ prop ];\n          conflicted = true;\n        }\n\n        model.$saved[ prop ] = copy( encoded[ prop ] );\n      }\n\n      if ( conflicted )\n      {\n        model.trigger( 'partial-update', [encoded, conflicts] );\n      }\n      else\n      {\n        model.trigger( 'full-update', [encoded, updated] );\n      }\n\n      model.trigger( 'remote-update', [encoded] );\n\n      model.$addOperation( NeuroSaveNow );\n    }\n    else\n    {\n      model = db.instantiate( decoded );\n\n      model.$local = encoded;\n      model.$saved = model.$local.$saved = copy( encoded );\n\n      model.$addOperation( NeuroSaveNow );\n    }\n\n    if ( !db.models.has( key ) )\n    {\n      db.models.put( key, model );\n      db.trigger( 'model-added', [model] );\n\n      model.trigger( 'saved' );\n    }\n\n    return model;\n  },\n\n  // Destroys a model locally because it doesn't exist remotely\n  destroyLocalModel: function(key)\n  {\n    var db = this;\n    var model = db.models.get( key );\n\n    if ( model )\n    {\n      // If a model was removed remotely but the model has changes - don't remove it.\n      if ( model.$hasChanges() )\n      {\n        // Removed saved history and the current ID\n        delete model.$saved;\n        delete model.$local.$saved;\n\n        db.removeKey( model );\n        db.removeKey( model.$local );\n\n        model.trigger( 'detach' );\n\n        model.$addOperation( NeuroSaveNow );\n     \n        return false;\n      }\n\n      model.trigger( 'remote-remove' );\n\n      model.$addOperation( NeuroRemoveNow );\n\n      db.models.remove( key );\n      db.trigger( 'model-removed', [model] );\n\n      model.trigger('removed');\n\n      Neuro.debug( Neuro.Events.REMOTE_REMOVE, model );\n    }\n    else\n    {\n      db.store.remove( key, function(removedValue)\n      {\n        if (removedValue) \n        {\n          Neuro.debug( Neuro.Events.REMOTE_REMOVE, removedValue );\n        }\n      });\n\n      // The model didn't exist\n      return false;\n    }\n\n    return true;\n  },\n\n  // Initialize the database by loading local values and on success load\n  // remove values.\n  init: function()\n  {\n    var db = this;\n\n    db.store.all(function(records, keys)\n    {\n      Neuro.debug( Neuro.Events.LOCAL_LOAD, records );\n\n      db.models.reset();\n\n      for (var i = 0; i < records.length; i++) \n      {\n        var encoded = records[ i ];\n        var key = keys[ i ];\n        var decoded = db.decode( copy( encoded, true ) );\n        var model = db.instantiate( decoded );\n\n        model.$local = encoded;\n\n        if ( encoded.$deleted )\n        {\n          Neuro.debug( Neuro.Events.LOCAL_RESUME_DELETE, model );\n\n          model.$addOperation( NeuroRemoveRemote );\n        }\n        else\n        {\n          if ( !encoded.$saved )\n          {\n            Neuro.debug( Neuro.Events.LOCAL_RESUME_SAVE, model );\n\n            model.$addOperation( NeuroSaveRemote );\n          }\n          else\n          {\n            Neuro.debug( Neuro.Events.LOCAL_LOAD_SAVED, model );\n\n            model.$local.$saved = model.$saved;\n          }\n\n          db.models.put( key, model );\n        }\n      }\n\n      db.trigger( 'local-load' );\n\n      db.updated();\n\n      if ( db.loadRemote !== false )\n      {\n        db.refresh();\n      }\n    });    \n  },\n\n  // Loads all data remotely\n  refresh: function()\n  {\n    var db = this;\n    var options = {\n      method: 'GET',\n      url: db.api\n    };\n\n    db.rest( options, onModels, onLoadError );\n    \n    function onModels(models) \n    {\n      var mapped = {};\n\n      for (var i = 0; i < models.length; i++)\n      {\n        var model = db.putRemoteData( models[ i ] );\n        var key = model.$key();\n\n        mapped[ key ] = model;\n      }\n\n      var keys = db.models.keys;\n\n      for (var i = 0; i < keys.length; i++)\n      {\n        var k = keys[ i ];\n\n        if ( !(k in mapped) )\n        {\n          var old = db.models.get( k );\n\n          if ( old.$saved )\n          {\n            Neuro.debug( Neuro.Events.REMOTE_LOAD_REMOVE, k );\n\n            db.destroyLocalModel( k );\n          }\n        }\n      }\n\n      db.trigger( 'remote-load' );\n\n      db.updated();\n\n      Neuro.debug( Neuro.Events.REMOTE_LOAD, models );\n    }\n\n    function onLoadError(models, status) \n    {\n      if ( status === 0 )\n      {\n        Neuro.checkNetworkStatus();\n\n        if ( !Neuro.online )\n        {\n          db.pendingRefresh = true;\n\n          Neuro.once('online', function()\n          {\n            Neuro.debug( Neuro.Events.REMOTE_LOAD_RESUME );\n\n            if ( db.pendingRefresh )\n            {\n              db.pendingRefresh = false;\n\n              db.refresh(); \n            }\n          })\n        }\n\n        Neuro.debug( Neuro.Events.REMOTE_LOAD_OFFLINE );\n      }\n      else\n      {\n        Neuro.debug( Neuro.Events.REMOTE_LOAD_ERROR, status );\n      }\n    }\n  \n  },\n\n  // The reference to all of the models in the database\n  getModels: function()\n  {\n    return this.models.values;\n  }, \n\n  // Returns a model\n  getModel: function(key)\n  {\n    if ( isArray( key ) )\n    {\n      var ks = this.keySeparator || '/';\n      var keyString = '';\n\n      for (var i = 0; i < key.length; i++)\n      {\n        if (i > 0)\n        {\n          keyString += ks;\n        }\n\n        keyString += key[ i ];\n      }\n\n      key = keyString;\n    }\n\n    return this.models.get( key );\n  },\n\n  // Crates a function for handling real-time changes\n  handlePublish: function(db)\n  {\n    return function(message)\n    {\n      var key = message.key;\n      var encoded = message.model;\n\n      switch (message.op) \n      {\n      case 'SAVE':\n\n        db.putRemoteData( encoded, key );\n        db.updated();\n\n        Neuro.debug( Neuro.Events.REALTIME_SAVE, message.model );\n        break;\n\n      case 'REMOVE':\n\n        if ( db.destroyLocalModel( key ) )\n        {\n          db.updated(); \n        }\n\n        Neuro.debug( Neuro.Events.REALTIME_REMOVE, key );\n        break;\n      }\n    };\n  },\n\n  // Return an instance of the model with the data as initial values\n  instantiate: function(data)\n  {\n    return new this.model( data );\n  },\n\n  // Converts properties in data into their storable form\n  encode: function(data)\n  {\n    return data;\n  },\n\n  // Converts properties in rawData from their storable form to their desired\n  decode: function(rawData)\n  {\n    return rawData;\n  },\n\n  // Save the model\n  save: function(model)\n  {\n    var db = this;\n    var key = model.$key();\n\n    // If the model is deleted, return immediately!\n    if ( model.$deleted )\n    {\n      Neuro.debug( Neuro.Events.SAVE_DELETED, model );\n\n      return;\n    }\n\n    // Place the model and trigger a database update.\n    if ( !db.models.has( key ) )\n    {\n      db.models.put( key, model );\n      db.trigger( 'model-added', [model] );\n      db.updated();\n\n      model.trigger('saved');\n    }\n    else\n    {\n      db.trigger( 'model-updated', [model] );\n    }\n\n    // Start by saving locally.\n    model.$addOperation( NeuroSaveLocal );\n  },\n\n  // Remove the model \n  remove: function(model)\n  {\n    var db = this;\n    var key = model.$key();\n\n    // If we have it in the models, remove it!\n    if ( db.models.has( key ) )\n    {\n      db.models.remove( key );\n      db.trigger( 'model-removed', [model] );\n      db.updated();\n\n      model.trigger('removed');\n    }\n\n    // Mark as deleted right away\n    model.$deleted = true;\n\n    // If we're offline and we have a pending save - cancel the pending save.\n    // TODO Add Debug here?\n    if ( model.$pendingSave )\n    {\n      Neuro.debug( Neuro.Events.REMOVE_CANCEL_SAVE, model );\n\n      model.$pendingSave = false; \n    }\n\n    // Start by removing locally.\n    model.$addOperation( NeuroRemoveLocal );\n  }\n\n};\n\neventize( NeuroDatabase.prototype );","\nfunction NeuroModel(db)\n{\n  this.$db = db;\n\n  /**\n   * @property {NeuroDatabase} $db\n   *           The reference to the database this model is stored in.\n   */\n\n  /**\n   * @property {Object} [$saved]\n   *           An object of encoded data representing the values saved remotely.\n   *           If this object does not exist - the model hasn't been created\n   *           yet.\n   */\n  \n  /**\n   * @property {Boolean} [$deleted]\n   *           A flag placed on a model once it's requested to be deleted. A  \n   *           model with this flag isn't present on any arrays - it's stored\n   *           locally until its successfully removed remotely - then it's \n   *           removed locally.\n   */\n  \n  /**\n   * @property {Object} [$local]\n   *           The object of encoded data that is stored locally. It's $saved\n   *           property is the same object as this $saved property.\n   */\n  \n  /**\n   * @property {Boolean} $pendingSave\n   *           Whether there is a pending save for this model.\n   */\n}\n\nNeuroModel.prototype =\n{\n\n  $init: function(props)\n  {\n    this.$pendingSave = false;\n    this.$operation = null;\n    this.$relations = {};\n\n    this.$reset( props );\n  },\n\n  $reset: function(props)\n  {\n    var def = this.$db.defaults;\n    var fields = this.$db.fields;\n\n    if ( isObject( def ) )\n    {\n      for (var i = 0; i < fields.length; i++)\n      {\n        var prop = fields[ i ];\n\n        if ( prop in def )\n        {\n          var defaultValue = def[ prop ];\n\n          if ( isFunction( defaultValue ) )\n          {\n            this[ prop ] = defaultValue();\n          }\n          else\n          {\n            this[ prop ] = copy( defaultValue );\n          }\n        }\n        else\n        {\n          this[ prop ] = undefined;\n        }\n      }\n    }\n    else\n    {\n      for (var i = 0; i < fields.length; i++)\n      {\n        var prop = fields[ i ];\n\n        this[ prop ] = undefined;\n      }\n    }\n\n    this.$set( props );\n  },\n\n  $set: function(props, value)\n  {\n    if ( isObject( props ) )\n    {\n      transfer( props, this );\n    }\n    else if ( isString( props ) && value !== void 0 )\n    {\n      if ( props in this.$relations )\n      {\n        var relation = this.$db.relations[ props ];\n\n        relation.set( this, value );\n      }\n      else\n      {\n        this[ props ] = value; \n      }\n    }\n  },\n\n  $get: function(props, copyValues)\n  {\n    if ( isArray( props ) )\n    {\n      return grab( this, props, copyValues );\n    }\n    else if ( isObject( props ) )\n    {\n      for (var p in props)\n      {\n        props[ p ] = copyValues ? copy( this[ p ] ) : this[ p ];\n      }\n\n      return props;\n    }\n    else if ( isString( props ) )\n    {\n      if ( props in this.$relations )\n      {\n        var relation = this.$db.relations[ props ];\n        var values = relation.get( this );\n\n        return copyValues ? copy( values ) : values;\n      }\n      else\n      {\n        return copyValues ? copy( this[ props ] ) : this[ props ]; \n      }\n    }\n  },\n\n  $save: function(setProperties, setValue)\n  {\n    this.$set( setProperties, setValue );\n\n    return this.$db.save( this );\n  },\n\n  $remove: function()\n  {\n    return this.$db.remove( this );\n  },\n\n  $addOperation: function(OperationType) \n  {\n    var operation = new OperationType( this );\n\n    if ( !this.$operation ) \n    {\n      this.$operation = operation;\n      this.$operation.execute();\n    } \n    else \n    {\n      this.$operation.queue( operation );\n    }\n  },\n\n  $toJSON: function()\n  {\n    return this.$db.encode( grab( this, this.$db.fields, true ) );\n  },\n\n  $key: function()\n  {\n    return this.$db.getKey( this );\n  },\n\n  $isSaved: function()\n  {\n    return !!this.$saved;\n  },\n\n  $isSavedLocally: function()\n  {\n    return !!this.$local;\n  },\n\n  $getChanges: function()\n  {\n    var saved = this.$saved;\n    var encoded = this.$toJSON();\n    var fields = this.$db.fields;\n\n    return saved ? diff( encoded, saved, fields, equals ) : encoded;\n  },\n\n  $hasChanges: function()\n  {\n    if (!this.$saved) \n    {\n      return true;\n    }\n\n    var encoded = this.$toJSON();\n    var saved = this.$saved;\n\n    for (var prop in encoded) \n    {\n      var currentValue = encoded[ prop ];\n      var savedValue = saved[ prop ];\n\n      if ( !equals( currentValue, savedValue ) ) \n      {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n};\n\neventize( NeuroModel.prototype );","\n/**\n * A NeuroMap has the key-to-value benefits of a map and iteration benefits of an\n * array. This is especially beneficial when most of the time the contents of \n * the structure need to be iterated and order doesn't matter (since removal \n * performs a swap which breaks insertion order).\n *\n * @constructor\n */\nfunction NeuroMap()\n{\n  /**\n   * An array of the values in this map.\n   * @member {Array}\n   */\n  this.values = [];\n\n  /**\n   * An array of the keys in this map.\n   * @type {Array}\n   */\n  this.keys = [];\n\n  /**\n   * An object of key to index mappings.\n   * @type {Object}\n   */\n  this.indices = {};\n}\n\nNeuroMap.prototype =\n{\n\n  /**\n   * Resets the map by initializing the values, keys, and indexes.\n   * \n   * @return {NeuroMap} -\n   *         The reference to this map.\n   */\n  reset: function()\n  {\n    this.values.length = 0;\n    this.keys.length = 0;\n    this.indices = {};\n\n    return this;\n  },\n\n  /**\n   * Puts the value in the map by the given key.\n   *\n   * @param {String} key\n   * @param {V} value\n   * @return {NeuroMap} -\n   *         The reference to this map.\n   */\n  put: function(key, value)\n  {\n    if ( key in this.indices )\n    {\n      this.values[ this.indices[ key ] ] = value;\n    }\n    else\n    {\n      this.indices[ key ] = this.values.length;\n      this.values.push( value );\n      this.keys.push( key );\n    }\n\n    return this;\n  },\n\n  /**\n   * Returns the value mapped by the given key.\n   *\n   * @param {String} key\n   * @return {V}\n   */\n  get: function(key)\n  {\n    return this.values[ this.indices[ key ] ];\n  },\n\n  /**\n   * Removes the value by a given key\n   *\n   * @param {String} key\n   * @return {NeuroMap} -\n   *         The reference to this map.\n   */\n  remove: function(key)\n  {\n    var index = this.indices[ key ];\n\n    if ( isNumber( index ) )\n    {\n      this.removeAt( index );\n    }\n\n    return this;\n  },\n\n  /**\n   * Removes the value & key at the given index.\n   *\n   * @param {Number} index\n   * @return {NeuroMap} -\n   *         The reference to this map.\n   */\n  removeAt: function(index)\n  {\n    var key = this.keys[ index ];\n    var lastValue = this.values.pop();\n    var lastKey = this.keys.pop();\n\n    if ( index < this.values.length )\n    {\n      this.values[ index ] = lastValue;\n      this.keys[ index ] = lastKey;\n      this.indices[ lastKey ] = index;\n    }\n\n    delete this.indices[ key ];\n\n    return this;\n  },\n\n  /**\n   * Returns whether this map has a value for the given key.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n  has: function(key)\n  {\n    return key in this.indices;\n  },\n\n  /**\n   * Returns the number of elements in the map.\n   *\n   * @return {Number}\n   */\n  size: function()\n  {\n    return this.values.length;\n  },\n\n  /**\n   * Passes all values & keys in this map to a callback and if it returns a \n   * truthy value then the key and value are placed in the destination map.\n   * \n   * @param  {Function} callback [description]\n   * @param  {NeuroMap} [dest]     [description]\n   * @return {[type]}            [description]\n   */\n  filter: function(callback, dest)\n  {\n    var out = dest || new NeuroMap();\n    var n = this.size();\n    var values = this.values;\n    var keys = this.keys;\n\n    for (var i = 0; i < n; i++)\n    {\n      var v = values[ i ];\n      var k = keys[ i ];\n\n      if ( callback( v, k ) )\n      {\n        out.put( k, v );\n      }\n    }\n\n    return out;\n  },\n\n  /**\n   * Reverses the order of the underlying values & keys.\n   * \n   * @return {NeuroMap} -\n   *         The referense to this map.\n   */\n  reverse: function()\n  {\n    var max = this.size() - 1;\n    var half = Math.ceil( max / 2 );\n\n    for (var i = 0; i < half; i++)\n    {\n      swap( this.values, i, max - i );\n      swap( this.keys, i, max - i );\n    }\n\n    this.rebuildIndex();\n\n    return this;\n  },\n\n  /**\n   * Sorts the underlying values & keys given a value compare function.\n   * \n   * @param  {function} comparator\n   *         A function which accepts two values and returns a number used for\n   *         sorting. If the first argument is less than the second argument, a\n   *         negative number should be returned. If the arguments are equivalent\n   *         then 0 should be returned, otherwise a positive number should be\n   *         returned.\n   * @return {NeuroMap} -\n   *         The reference to this map.\n   */\n  sort: function(comparator)\n  {\n    var map = this;\n\n    // Sort this partition!\n    function partition(left, right)\n    {\n      var pivot = map.values[ Math.floor((right + left) / 2) ];\n      var i = left;\n      var j = right;\n\n      while (i <= j) \n      {\n        while (comparator( map.values[i], pivot ) < 0) i++\n        while (comparator( map.values[j], pivot ) > 0) j--;\n\n        if (i <= j) {\n          swap( map.values, i, j );\n          swap( map.keys, i, j );\n          i++;\n          j--;\n        }\n      }\n\n      return i;\n    }\n\n    // Quicksort\n    function qsort(left, right)\n    {\n      var index = partition( left, right );\n\n      if (left < index - 1) \n      {\n        qsort( left, index - 1 );\n      }\n\n      if (index < right) \n      {\n        qsort( index, right );\n      }\n    }\n\n    var right = this.size() - 1;\n\n    // Are there elements to sort?\n    if ( right > 0 )\n    {\n      qsort( 0, right );\n\n      this.rebuildIndex();\n    }\n\n    return this;\n  },\n\n  /**\n   * Rebuilds the index based on the keys.\n   * \n   * @return {NeuroMap} -\n   *         The reference to this map.\n   */\n  rebuildIndex: function()\n  {\n    this.indices = {};\n\n    for (var i = 0, l = this.keys.length; i < l; i++)\n    {\n      this.indices[ this.keys[ i ] ] = i;\n    }\n\n    return this;\n  }\n\n};","\nfunction NeuroOperation(interrupts)\n{\n  this.interrupts = interrupts;\n}\n\nNeuroOperation.prototype = \n{\n  reset: function(model)\n  {\n    this.model = model;\n    this.db = model.$db;\n    this.next = null;\n    this.finished = false;\n  },\n\n  queue: function(operation)\n  {\n    if ( this.next && !operation.interrupts )\n    {\n      this.next.queue( operation );\n    }\n    else\n    {\n      this.next = operation;\n    }\n  },\n\n  execute: function()\n  {\n    this.run( this.db, this.model );\n  },\n\n  run: function(db, model)\n  {\n    throw 'NeuroOperation.run Not implemented';\n  },\n\n  finish: function()\n  {\n    if ( !this.finished )\n    {\n      this.finished = true;\n\n      if ( this.model.$operation = this.next )\n      {\n        this.next.execute();\n      }\n    }\n\n    return this;\n  },\n\n  tryNext: function(OperationType)\n  {\n    if ( !this.next )\n    {\n      this.next = new OperationType( this.model );\n    }\n  },\n\n  insertNext: function(OperationType)\n  {\n    var op = new OperationType( this.model );\n\n    op.next = this.next;\n    this.next = op;\n  },\n\n  success: function()\n  {\n    var op = this;\n\n    return function handleSuccess() \n    {\n      op.onSuccess.apply( op, arguments );\n      op.finish();\n    };\n  },\n\n  onSuccess: function()\n  {\n\n  },\n\n  failure: function()\n  {\n    var op = this;\n\n    return function handleFailure() \n    {\n      op.onFailure.apply( op, arguments );\n      op.finish();\n    };\n  },\n\n  onFailure: function()\n  {\n\n  }\n\n};\n\n/**\n\n$operation;\n\n$addOperation: function(OperationType) {\n  var operation = new OperationType( this );\n  if ( !this.$operation ) {\n    this.$operation = operation;\n    this.$operation.execute();\n  } else {\n    this.$operation.queue( operation );\n  }\n}\n\n */","function NeuroRemoveLocal(model)\n{\n  this.reset( model );\n}\n\nNeuroRemoveLocal.prototype = new NeuroOperation( true );\n\nNeuroRemoveLocal.prototype.run = function(db, model)\n{\n  var key = model.$key();\n\n  // If there is no local there's nothing to remove from anywhere!\n  if ( !model.$local )\n  {\n    Neuro.debug( Neuro.Events.REMOVE_LOCAL_NONE, model );\n\n    return this.finish();\n  }\n\n  // If this model hasn't been saved we only need to remove it from local storage.\n  if ( model.$saved )\n  {\n    // Mark local copy as deleted in the event we're not online\n    model.$local.$deleted = true;\n\n    db.store.put( key, model.$local, this.success(), this.failure() );\n  }\n  else\n  {\n    Neuro.debug( Neuro.Events.REMOVE_LOCAL_UNSAVED, model );\n\n    db.store.remove( key, this.success(), this.failure() );\n  }\n};\n\nNeuroRemoveLocal.prototype.onSuccess = function(key, encoded, previousValue)\n{\n  var model = this.model;\n\n  Neuro.debug( Neuro.Events.REMOVE_LOCAL, model );\n\n  if ( model.$saved )\n  {\n    model.$addOperation( NeuroRemoveRemote );\n  }\n};\n\nNeuroRemoveLocal.prototype.onFailure = function(e)\n{\n  var model = this.model;\n\n  Neuro.debug( Neuro.Events.REMOVE_LOCAL_ERROR, model, e );\n\n  if ( model.$saved )\n  {\n    model.$addOperation( NeuroRemoveRemote );\n  }\n};","function NeuroRemoveNow(model)\n{\n  this.reset( model );\n}\n\nNeuroRemoveNow.prototype = new NeuroOperation( true );\n\nNeuroRemoveNow.prototype.run = function(db, model)\n{\n  var key = model.$key();\n\n  if ( db.models.has( key ) )\n  {\n    db.models.remove( key );\n    db.trigger( 'model-removed', [model] );\n    db.updated();\n\n    model.trigger('removed');\n  }\n\n  db.store.remove( key, this.success(), this.failure() );\n};","function NeuroRemoveRemote(model)\n{\n  this.reset( model );\n}\n\nNeuroRemoveRemote.prototype = new NeuroOperation( true );\n\nNeuroRemoveRemote.prototype.run = function(db, model)\n{\n  // Cancel any pending saves\n  model.$pendingSave = false;\n  model.$deleted = true;\n\n  // Grab key & encode to JSON\n  this.key = model.$key();\n\n  // Make the REST call to remove the model\n  var options = {\n    method: 'DELETE',\n    url:    db.api + this.key\n  };\n\n  db.rest( options, this.success(), this.failure() );\n};\n\nNeuroRemoveRemote.prototype.onSuccess = function(data)\n{\n  this.finishRemove();\n};\n\nNeuroRemoveRemote.prototype.onFailure = function(data, status)\n{\n  var key = this.key;\n  var model = this.model;\n\n  if ( status === 404 || status === 410 )\n  {\n    Neuro.debug( Neuro.Events.REMOVE_MISSING, key, model );\n\n    this.finishRemove();\n  }\n  else if ( status !== 0 ) \n  {\n    Neuro.debug( Neuro.Events.REMOVE_ERROR, status, key, model );\n  } \n  else \n  {\n    // Looks like we're offline!\n    Neuro.checkNetworkStatus();\n\n    // If we are offline, wait until we're online again to resume the delete\n    if (!Neuro.online) \n    {\n      Neuro.once('online', function() \n      {\n        Neuro.debug( Neuro.Events.REMOVE_RESUME, model );\n\n        model.$addOperation( NeuroRemoveRemote );\n      });\n    }\n\n    Neuro.debug( Neuro.Events.REMOVE_OFFLINE, model );\n  }\n};\n\nNeuroRemoveRemote.prototype.finishRemove = function()\n{\n  var db = this.db;\n  var key = this.key;\n  var model = this.model;\n\n  Neuro.debug( Neuro.Events.REMOVE_REMOTE, key, model );\n\n  // Remove from local storage now\n  this.insertNext( NeuroRemoveNow );\n\n  // Publish REMOVE\n  Neuro.debug( Neuro.Events.REMOVE_PUBLISH, key, model );\n\n  db.live({\n    op: 'REMOVE',\n    key: key\n  });\n};","function NeuroSaveLocal(model)\n{\n  this.reset( model );\n}\n\nNeuroSaveLocal.prototype = new NeuroOperation( false );\n\nNeuroSaveLocal.prototype.run = function(db, model)\n{\n  // If the model is deleted, return immediately!\n  if ( model.$deleted )\n  {\n    Neuro.debug( Neuro.Events.SAVE_LOCAL_DELETED, model );\n\n    return this.finish();\n  }\n\n  var encoded = model.$toJSON();\n\n  // If this model doesn't have a local copy yet - create it.\n  if ( !model.$local ) \n  {\n    model.$local = encoded;\n  } \n  else \n  {\n    // Copy to the local copy\n    transfer( encoded, model.$local );\n  }\n\n  db.store.put( model.$key(), model.$local, this.success(), this.failure() );\n};\n\nNeuroSaveLocal.prototype.onSuccess = function(key, encoded, previousValue)\n{\n  var model = this.model;\n\n  Neuro.debug( Neuro.Events.SAVE_LOCAL, model );\n\n  this.tryNext( NeuroSaveRemote );\n};\n\nNeuroSaveLocal.prototype.onFailure = function(e)\n{\n  var model = this.model;\n\n  Neuro.debug( Neuro.Events.SAVE_LOCAL_ERROR, model, e );\n\n  this.tryNext( NeuroSaveRemote );\n};","function NeuroSaveNow(model)\n{\n  this.reset( model );\n}\n\nNeuroSaveNow.prototype = new NeuroOperation( false );\n\nNeuroSaveNow.prototype.run = function(db, model)\n{\n  db.store.put( model.$key(), model.$local, this.success(), this.failure() );\n};","function NeuroSaveRemote(model)\n{\n  this.reset( model );\n}\n\nNeuroSaveRemote.prototype = new NeuroOperation( false );\n\nNeuroSaveRemote.prototype.run = function(db, model)\n{\n  // If the model is deleted, return immediately!\n  if ( model.$deleted )\n  {\n    Neuro.debug( Neuro.Events.SAVE_REMOTE_DELETED, model );\n\n    return this.finish();\n  }\n\n  // Grab key & encode to JSON\n  var key = this.key = model.$key();\n\n  // The fields that have changed since last save\n  var saving = this.saving = model.$getChanges();\n\n  // If there's nothing to save, don't bother!\n  if ( isEmpty( saving ) )\n  {\n    return this.finish();\n  }\n\n  // Make the REST call to remove the model\n  var options = {\n    method: model.$saved ? 'PUT' : 'POST',\n    url:    model.$saved ? db.api + key : db.api,\n    data:   saving\n  };\n\n  db.rest( options, this.success(), this.failure() );\n};\n\nNeuroSaveRemote.prototype.onSuccess = function(data)\n{\n  var model = this.model;\n\n  Neuro.debug( Neuro.Events.SAVE_REMOTE, model );\n\n  this.handleData( data );\n};\n\nNeuroSaveRemote.prototype.onFailure = function(data, status)\n{\n  var db = this.db;\n  var model = this.model;\n\n  // A non-zero status means a real problem occurred\n  if ( status === 409 ) // 409 Conflict\n  {\n    Neuro.debug( Neuro.Events.SAVE_CONFLICT, data, model );\n\n    // Update the model with the data saved and returned\n    this.handleData( data, model, this.db );\n  }\n  else if ( status === 410 || status === 404 ) // 410 Gone, 404 Not Found\n  {\n    Neuro.debug( Neuro.Events.SAVE_UPDATE_FAIL, model );\n\n    this.insertNext( NeuroRemoveNow );\n  }\n  else if ( status !== 0 ) \n  {          \n    Neuro.debug( Neuro.Events.SAVE_ERROR, model, status );\n  } \n  else \n  {\n    // Check the network status right now\n    Neuro.checkNetworkStatus();\n\n    // If not online for sure, try saving once online again\n    if (!Neuro.online) \n    {\n      model.$pendingSave = true;\n\n      Neuro.once('online', function() \n      {\n        if ( model.$pendingSave )\n        { \n          model.$pendingSave = false;\n          model.$addOperation( NeuroSaveRemote );\n\n          Neuro.debug( Neuro.Events.SAVE_RESUME, model );\n        }\n      });\n    }\n\n    Neuro.debug( Neuro.Events.SAVE_OFFLINE, model );\n  }\n};\n\nNeuroSaveRemote.prototype.handleData = function(data)\n{\n  var db = this.db;\n  var model = this.model;\n  var saving = this.saving;\n\n  // Check deleted one more time before updating model.\n  if ( model.$deleted )\n  {\n    Neuro.debug( Neuro.Events.SAVE_REMOTE_DELETED, model, data );\n\n    return;\n  }\n\n  // If data was returned, place it in saving to update the model and publish\n  for (var prop in data)\n  {\n    if ( !(prop in saving ) )\n    {\n      saving[ prop ] = data[ prop ];\n    }\n  }\n\n  Neuro.debug( Neuro.Events.SAVE_VALUES, saving, model );\n\n  // If the model hasn't been saved before - create the record where the \n  // local and model point to the same object.\n  if ( !model.$saved )\n  {\n    model.$saved = model.$local.$saved = {};\n  }\n  \n  // Update the model with the return data\n  db.putRemoteData( saving, this.key, model );\n\n  // Publish saved data to everyone else\n  Neuro.debug( Neuro.Events.SAVE_PUBLISH, saving, model );\n\n  db.live({\n    op: 'SAVE',\n    model: saving,\n    key: this.key\n  });\n};","\nNeuro.debug = function(event, data)\n{\n  // up to the user\n};\n\nNeuro.Events = {\n\n  CREATION: 0,                // options, NeuroDatabase\n\n  REST: 1,                    // options\n\n  REMOTE_UPDATE: 2,           // encoded, NeuroModel\n  REMOTE_CREATE: 3,           // encoded, NeuroModel\n  REMOTE_REMOVE: 4,           // NeuroModel\n  REMOTE_LOAD: 5,             // encoded[]\n  REMOTE_LOAD_OFFLINE: 6,     // \n  REMOTE_LOAD_ERROR: 7,       // status\n  REMOTE_LOAD_REMOVE: 8,      // key\n  REMOTE_LOAD_RESUME: 22,     // \n\n  LOCAL_LOAD: 9,              // encoded[]\n  LOCAL_RESUME_DELETE: 10,    // NeuroModel\n  LOCAL_RESUME_SAVE: 11,      // NeuroModel\n  LOCAL_LOAD_SAVED: 12,       // NeuroModel\n\n  REALTIME_SAVE: 13,          // encoded\n  REALTIME_REMOVE: 14,        // key\n\n  SAVE_VALUES: 15,            // encoded, NeuroModel\n  SAVE_PUBLISH: 16,           // encoded, NeuroModel\n  SAVE_CONFLICT: 17,          // encoded, NeuroModel\n  SAVE_UPDATE_FAIL: 18,       // NeuroModel\n  SAVE_ERROR: 19,             // NeuroModel, status\n  SAVE_OFFLINE: 20,           // NeuroModel\n  SAVE_RESUME: 21,            // NeuroModel\n  SAVE_REMOTE: 25,            // NeuroModel\n  SAVE_DELETED: 40,           // NeuroModel\n\n  SAVE_LOCAL: 23,             // NeuroModel\n  SAVE_LOCAL_ERROR: 24,       // NeuroModel, error\n  SAVE_LOCAL_DELETED: 38,     // NeuroModel\n  SAVE_LOCAL_BLOCKED: 39,     // NeuroModel\n\n  SAVE_REMOTE_DELETED: 41,    // NeuroModel, [encoded]\n  SAVE_REMOTE_BLOCKED: 42,    // NeuroModel\n\n  REMOVE_PUBLISH: 26,         // key, NeuroModel\n  REMOVE_LOCAL: 27,           // key, NeuroModel\n  REMOVE_MISSING: 28,         // key, NeuroModel\n  REMOVE_ERROR: 29,           // status, key, NeuroModel\n  REMOVE_OFFLINE: 30,         // NeuroModel\n  REMOVE_RESUME: 31,          // NeuroModel\n  REMOVE_REMOTE: 32,          // NeuroModel\n  REMOVE_CANCEL_SAVE: 47,     // NeuroModel\n\n  REMOVE_LOCAL: 33,           // NeuroModel\n  REMOVE_LOCAL_ERROR: 34,     // NeuroModel, error\n  REMOVE_LOCAL_BLOCKED: 44,   // NeuroModel\n  REMOVE_LOCAL_NONE: 45,      // NeuroModel\n  REMOVE_LOCAL_UNSAVED: 46,   // NeuroModel\n\n  REMOVE_REMOTE_BLOCKED: 43,  // NeuroModel\n\n  ONLINE: 35,                 //\n  OFFLINE: 36,                //\n\n  PUBSUB_CREATED: 37          // PubSub\n\n};","\n// Neuro.rest = function(options, success(data), failure(data, status))\n\nNeuro.rest = function(database)\n{\n  return function (options, success, failure)\n  {\n    // success ( data )\n    // failure ( data, status )\n    \n    failure( {}, 0 );\n  };\n};","/**\n * A factory function for returning an object capable of storing objects for\n * retrieval later by the application.\n * \n * @param  {NeuroDatabase} database\n *         The database this store is for.\n * @return {Object} -\n *         An object with put, remove, and all functions.\n */\nNeuro.store = function(database)\n{\n  return {\n\n    /**\n     * Places a record in the store with the given key.\n     * \n     * @param  {String|Number} key\n     *         The key to store the record as.\n     * @param  {Object} record\n     *         The record to store.\n     * @param  {function} success\n     *         A function to invoke when the record is successfully stored with\n     *         the key. The arguments of the function should be the key and \n     *         record passed to this function.\n     * @param  {function} failure\n     *         A function to invoke when the record failed to be stored with the\n     *         key. The arguments of the function should be the key, record, and\n     *         an error that occurred if available.\n     */\n    put: function(key, record, success, failure) \n    { \n      // implement\n    },\n\n    /**\n     * Removes a record from the store with the given key.\n     * \n     * @param  {String|Number} key\n     *         The key to remove from the store.\n     * @param  {[type]} success\n     *         A function to invoke when the record doesn't exist in the store.\n     *         The arguments of the function are the removedValue (if any) and\n     *         the key passed to this function.\n     * @param  {[type]} failure\n     *         A function to invoke when there was an issue removing the key\n     *         from the store. The arguments of the function are the key given\n     *         to this function and an error that occurred if available.\n     */\n    remove: function(key, success, failure) \n    {\n      // implement\n    },\n\n    /**\n     * Returns all records and their keys to the given success callback.\n     * \n     * @param  {function} success\n     *         The function to invoke with the array of records and an array\n     *         of keys.\n     * @param  {function} failure\n     *         The function to invoke with the error that occurred if available.\n     */\n    all: function(success, failure) \n    {\n      // implement\n    }\n\n  };\n\n};","\n/**\n * The factory responsible for creating a service which publishes operations\n * and receives operations that have occurred. The first argument is a reference\n * to the NeuroDatabase and the second argument is a function to invoke when a\n * live operation occurs. This function must return a function that can be passed\n * an operation to be delegated to other clients.\n * \n * @param  {NeuroDatabase} database\n *         The database this live function is for.\n * @param  {function} onPublish\n *         The function which receives live operations.\n * @return {function} -\n *         The function which sends operations.\n */\nNeuro.live = function(database, onPublish)\n{\n  return function publish(message)\n  {\n    // ignore the message.\n  };\n};","\n// Initial online\nNeuro.online = window.navigator.onLine !== false;\n\nNeuro.forceOffline = false;\n\n// Set network status to online and notify all listeners\nNeuro.setOnline = function()\n{\n  Neuro.online = true;\n  Neuro.debug( Neuro.Events.ONLINE );\n  Neuro.trigger('online');\n};\n\n// Set network status to offline and notify all listeners\nNeuro.setOffline = function()\n{\n  Neuro.online = false;\n  Neuro.debug( Neuro.Events.OFFLINE );\n  Neuro.trigger('offline');\n};\n\n// This must be called manually - this will try to use built in support for \n// online/offline detection instead of solely using status codes of 0.\nNeuro.listenToNetworkStatus = function()\n{\n  if (window.addEventListener) \n  {\n    window.addEventListener( 'online', Neuro.setOnline, false );\n    window.addEventListener( 'offline', Neuro.setOffline, false );\n  } \n  else \n  {\n    document.body.ononline = Neuro.setOnline;\n    document.body.onoffline = Neuro.setOffline;\n  }\n};\n\n// Check to see if the network status has changed.\nNeuro.checkNetworkStatus = function()\n{\n  var online = window.navigator.onLine;\n\n  if ( Neuro.forceOffline ) \n  {\n    online = false;\n  }\n\n  if (online === true && Neuro.online === false) \n  {\n    Neuro.setOnline();\n  }\n\n  else if (online === false && Neuro.online === true) \n  {\n    Neuro.setOffline();\n  }\n};","\n  global.Neuro = Neuro;\n\n})(window);"],"sourceRoot":"/source/"}