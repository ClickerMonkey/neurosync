{"version":3,"sources":["header.js","functions.js","eventize.js","Neuro.js","NeuroDatabase.js","NeuroModel.js","Neuro_debug.js","Neuro_rest.js","Neuro_pubsub.js","Neuro_offline.js","footer.js"],"names":["global","undefined","isDefined","x","isFunction","constructor","call","apply","isString","isDate","Date","isRegExp","RegExp","isArray","Array","isObject","toArray","split","S4","Math","random","toString","substring","uuid","transfer","from","to","prop","grab","obj","props","copyValues","grabbed","i","length","p","copy","copyHidden","c","push","getTime","source","match","charAt","diff","curr","old","comparator","d","equals","a","b","at","bt","aa","ba","eventize","target","onListeners","$this","property","events","callback","context","on","this","once","offListeners","listeners","event","eventListeners","k","splice","deleteProperty","off","$on","$once","triggerListeners","argument","clear","max","slice","trigger","e","Neuro","options","database","NeuroDatabase","model","Function","className","prototype","NeuroModel","db","init","debug","Events","CREATION","Database","Model","pubsub","getPubSub","stork","Stork","models","FastMap","channel","subscribe","token","onpublish","handlePublish","$db","$promise","Promise","Done","$pendingSave","$pendingRemove","data","REST","REMOTE_UPDATE","REMOTE_CREATE","REMOTE_REMOVE","REMOTE_LOAD","REMOTE_LOAD_OFFLINE","REMOTE_LOAD_ERROR","REMOTE_LOAD_REMOVE","REMOTE_LOAD_RESUME","LOCAL_LOAD","LOCAL_RESUME_DELETE","LOCAL_RESUME_SAVE","LOCAL_LOAD_SAVED","REALTIME_SAVE","REALTIME_REMOVE","SAVE_VALUES","SAVE_PUBLISH","SAVE_CONFLICT","SAVE_UPDATE_FAIL","SAVE_ERROR","SAVE_OFFLINE","SAVE_RESUME","SAVE_REMOTE","SAVE_DELETED","SAVE_LOCAL","SAVE_LOCAL_ERROR","SAVE_LOCAL_DELETED","SAVE_LOCAL_BLOCKED","SAVE_REMOTE_DELETED","SAVE_REMOTE_BLOCKED","REMOVE_PUBLISH","REMOVE_LOCAL","REMOVE_MISSING","REMOVE_ERROR","REMOVE_OFFLINE","REMOVE_RESUME","REMOVE_REMOTE","REMOVE_CANCEL_SAVE","REMOVE_LOCAL_ERROR","REMOVE_LOCAL_BLOCKED","REMOVE_LOCAL_NONE","REMOVE_LOCAL_UNSAVED","REMOVE_REMOTE_BLOCKED","ONLINE","OFFLINE","PUBSUB_CREATED","rest","promise","$failure","url","pubsubs","PubSub","online","window","navigator","onLine","forceOffline","setOnline","setOffline","listenToNetworkStatus","addEventListener","document","body","ononline","onoffline","checkNetworkStatus","$pendingLoad","generateKey","updated","sort","putRemoteData","encoded","key","get","decoded","decode","$saved","current","$toJSON","currentValue","savedValue","$local","$queue","save","instantiate","put","destroyLocalModel","$hasChanges","remove","removedValue","PROMISED","$success","all","records","keys","reset","inst","$deleted","removeRemote","saveRemote","loadRemote","loadPromise","method","then","mapped","$key","status","getModels","values","message","op","encode","rawData","waitForPending","args","$pending","either","$reset","interruptPending","$clear","promiseRest","arguments","$saving","fields","finishSave","publish","has","saveLocal","mdoel","localSave","removeModel","$bindTo","removeLocal","localRemove","$set","value","$get","$save","setProperties","setValue","$remove","interrupt","def","defaults","$isSaved","$isSavedLocally","saved"],"mappings":"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","file":"neurosync.min.js","sourcesContent":["(function(global, undefined)\n{\n","\n\nfunction isDefined(x)\n{\n  return typeof x !== 'undefined';\n}\n\nfunction isFunction(x)\n{\n  return !!(x && x.constructor && x.call && x.apply);\n}\n\nfunction isString(x)\n{\n  return typeof x === 'string';\n}\n\nfunction isDate(x)\n{\n  return x instanceof Date;\n}\n\nfunction isRegExp(x)\n{\n  return x instanceof RegExp;\n}\n\nfunction isArray(x)\n{\n  return x instanceof Array;\n}\n\nfunction isObject(x)\n{\n  return x !== null && typeof x === 'object';\n}\n\nfunction toArray(x, split)\n{\n  return x instanceof Array ? x : x.split( split );\n}\n\nfunction S4() \n{\n  return (((1+Math.random())*0x10000)|0).toString(16).substring(1);\n}\n\nfunction uuid() \n{\n    return (S4()+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+S4()+S4());\n}\n\nfunction transfer(from, to)\n{\n  for (var prop in from)\n  {\n    to[ prop ] = from[ prop ];\n  }\n\n  return to;\n}\n\nfunction grab(obj, props, copyValues)\n{\n  var grabbed = {};\n\n  for (var i = 0; i < props.length; i++) \n  {\n    var p = props[ i ];\n\n    if ( p in obj ) \n    {\n      grabbed[ p ] = copyValues ? copy( obj[ p ] ) : obj[ p ];\n    }\n  }\n\n  return grabbed;\n}\n\nfunction copy(x, copyHidden)\n{\n  if (x === void 0)\n  {\n    return x;\n  }\n  if (isArray(x)) \n  {\n    var c = [];\n\n    for (var i = 0; i < x.length; i++) \n    {\n      c.push( copy(x[i]) );\n    }\n    return x;\n  }\n  if (isFunction(x) || typeof x !== 'object' || x === null)\n  {\n    return x;\n  }\n  if (isDate(x))\n  {\n    return new Date( x.getTime() );\n  }\n  if (isRegExp(x))\n  {\n    return new RegExp( x.source, x.toString().match(/[^\\/]*$/)[0] );\n  }\n\n  var c = {};\n\n  for (var prop in x) \n  {\n    if (copyHidden || prop.charAt(0) !== '$')\n    {\n      c[ prop ] = copy( x[prop] );\n    }\n  }\n\n  return c;\n}\n\nfunction diff(curr, old, props, comparator)\n{\n  var d = {};\n\n  for (var i = 0; i < props.length; i++)\n  {\n    var p = props[ i ];\n\n    if (p in curr && p in old && !comparator( curr[ p ], old[ p ] ) )\n    {\n      d[ p ] = copy( curr[ p ] );\n    }\n  }\n\n  return d;\n}\n\nfunction equalsStrict(a, b)\n{\n  return a === b;\n}\n\nfunction equals(a, b)\n{\n  if (a === b) return true;\n  if (a === null || b === null) return false;\n  if (a !== a && b !== b) return true; // NaN === NaN\n\n  var at = typeof a;\n  var bt = typeof b;\n  if (at !== bt) return false;\n\n  var aa = isArray(a);\n  var ba = isArray(b);\n  if (aa !== ba) return false;\n\n  if (aa) {\n    if (a.length !== b.length) return false;\n    for (var i = 0; i < a.length; i++) {\n      if (!equals(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if (isDate(a)) {\n    return isDate(b) && equals( a.getTime(), b.getTime() );\n  }\n  if (isRegExp(a)) {\n    return isRegExp(b) && a.toString() === b.toString();\n  }\n\n  if (at === 'object') {\n    for (var p in a) {\n      if (p.charAt(0) !== '$' || !isFunction(a[p])) {\n        if (!(p in b) || !equals(a[p], b[p])) {\n          return false;\n        }\n      }\n    }\n    for (var p in b) {\n      if (p.charAt(0) !== '$' || !isFunction(b[p])) {\n        if (!(p in a)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  return false;\n}\n","\n/**\n * Adds functions to the given object (or prototype) so you can listen for any \n * number of events on the given object, optionally once. Listeners can be \n * removed later.\n *\n * The following methods will be added to the given target:\n *\n *     target.on( events, callback, [context] )\n *     target.once( events, callback, [context] )\n *     target.off( events, callback )\n *     target.trigger( event, [argument] )\n *\n * Where... \n * - `events` is a string of space delimited events.\n * - `callback` is a function to invoke when the event is triggered.\n * - `context` is an object that should be the `this` when the callback is \n *   invoked. If no context is given the default value is the object which has \n *   the trigger function that was invoked.\n *\n * @method eventize\n * @for Core\n * @param {Object} target The object to add `on`, `once`, `off`, and `trigger` \n *    functions to.\n */\nfunction eventize(target)\n{\n  /**\n   * **See:** {{#crossLink \"Core/eventize:method\"}}{{/crossLink}}\n   * \n   * @class eventize\n   */\n\n  // Adds a listener to $this\n  var onListeners = function($this, property, events, callback, context)\n  {\n    var events = toArray( events, ' ' );\n    \n    if ( !isDefined( $this[ property ] ) )\n    {\n      $this[ property ] = {};\n    }\n    \n    for (var i = 0; i < events.length; i++)\n    {\n      if ( !isDefined( $this[ property ][ events[i] ] ) )\n      {\n        $this[ property ][ events[i] ] = [];\n      }\n      \n      $this[ property ][ events[i] ].push( [ callback, context || $this ] );\n    }\n  };\n  \n  /**\n   * Listens for every occurrence of the given events and invokes the callback\n   * each time any of them are triggered.\n   * \n   * @method on\n   * @for eventize\n   * @param {String|Array|Object} events\n   * @param {Function} callback\n   * @param {Object} [context]\n   * @chainable\n   */\n  target.on = function(events, callback, context)\n  {\n    onListeners( this, '$on', events, callback, context );\n\n    return this;\n  };\n  \n  /**\n   * Listens for the next occurrence for each of the given events and invokes\n   * the callback when any of the events are triggered.\n   * \n   * @method once\n   * @for eventize\n   * @param {String|Array|Object} events\n   * @param {Function} callback\n   * @param {Object} [context]\n   * @chainable\n   */\n  target.once = function(events, callback, context)\n  {\n    onListeners( this, '$once', events, callback, context );\n\n    return this;\n  };\n  \n  // Removes a listener from an array of listeners.\n  var offListeners = function(listeners, event, callback)\n  {\n    if (listeners && event in listeners)\n    {\n      var eventListeners = listeners[ event ];\n      \n      for (var k = eventListeners.length - 1; k >= 0; k--)\n      {\n        if (eventListeners[ k ][0] === callback)\n        {\n          eventListeners.splice( k, 1 );\n        }\n      }  \n    }\n  };\n\n  // Deletes a property from the given object if it exists\n  var deleteProperty = function(obj, prop)\n  {\n    if ( obj && prop in obj )\n    {\n      delete obj[ prop ];\n    }\n  };\n  \n  /**\n   * Stops listening for a given callback for a given set of events.\n   *\n   * **Examples:**\n   *\n   *     target.off();           // remove all listeners\n   *     target.off('a b');      // remove all listeners on events a & b\n   *     target.off(['a', 'b']); // remove all listeners on events a & b\n   *     target.off('a', x);     // remove listener x from event a\n   * \n   * @method off\n   * @for eventize\n   * @param {String|Array|Object} [events]\n   * @param {Function} [callback]\n   * @chainable\n   */\n  target.off = function(events, callback)\n  {\n    // Remove ALL listeners\n    if ( !isDefined( events ) )\n    {\n      deleteProperty( this, '$on' );\n      deleteProperty( this, '$once' );\n    }\n    else\n    {\n      var events = toArray( events, ' ' );\n\n      // Remove listeners for given events\n      if ( !isFunction( callback ) )\n      {\n        for (var i = 0; i < events.length; i++)\n        {\n          deleteProperty( this.$on, events[i] );\n          deleteProperty( this.$once, events[i] );\n        }\n      }\n      // Remove specific listener\n      else\n      {\n        for (var i = 0; i < events.length; i++)\n        {\n          offListeners( this.$on, events[i], callback );\n          offListeners( this.$once, events[i], callback );\n        }\n      }\n    }\n\n    return this;\n  };\n  \n  // Triggers listeneers for the given event\n  var triggerListeners = function(listeners, event, argument, clear)\n  {\n    if (listeners && event in listeners)\n    {\n      var eventListeners = listeners[ event ];\n      var max = eventListeners.length;\n     \n      for (var i = 0; i < max; i++)\n      {\n        var callback = eventListeners[ i ];\n        \n        callback[0].call( callback[1], argument );\n      }\n      \n      if ( clear )\n      {\n        if ( eventListeners.length !== max )\n        {\n          listeners[ event ] = eventListeners.slice( max );  \n        }\n        else\n        {\n          delete listeners[ event ];  \n        }\n      }\n    }\n  };\n  \n  /**\n   * Triggers a single event optionally passing an argument to any listeners.\n   * \n   * @method trigger\n   * @for eventize\n   * @param {String} event\n   * @param {Any} argument\n   * @chainable\n   */\n  target.trigger = function(events, argument)\n  {\n    var events = toArray( events, ' ' );\n\n    for (var i = 0; i < events.length; i++)\n    {\n      var e = events[ i ];\n\n      triggerListeners( this.$on, e, argument, false );\n      triggerListeners( this.$once, e, argument, true );\n    }\n\n    return this;\n  };\n};","\n/*\nnew Neuro({\n  name: 'name',\n  rest: 'http://api/name',\n  pubsub: 'http://url:port',\n  channel: 'houseid',\n  token: 'userid',\n  timestamp: 'updated_at',              // server returns new updated_at & old, old is compared against current\n  key: 'id',\n  fields: ['id', 'name', 'updated_at'],\n//  encode: function() {},\n//  decode: function() {}\n});\n*/\n\nfunction Neuro(options)\n{\n  var database = new NeuroDatabase( options );\n\n  var model = new Function('return function ' + options.className + '(props) { this.$set( props ) }')();\n  model.prototype = new NeuroModel( database );\n  model.db = database;\n\n  database.model = model;\n  database.init();\n\n  Neuro.debug( Neuro.Events.CREATION, options, database );\n  \n  return {\n    Database: database, \n    Model: model\n  };\n}\n\neventize( Neuro );\n","\n\nfunction NeuroDatabase(options)\n{  \n  transfer( options, this );\n\n  var pubsub = Neuro.getPubSub( options.pubsub );\n\n  this.stork = new Stork( options );\n  this.models = new Stork.FastMap();\n\n  this.channel = pubsub.subscribe( options.channel, options.token );\n  this.channel.onpublish = this.handlePublish( this );\n}\n\nNeuroDatabase.prototype =\n{\n\n  // Whether or not there's a load pending until we're online again\n  $pendingLoad: false,\n\n  // The method responsible for generating a key for the models in the database.\n  generateKey: function()\n  {\n    return uuid();\n  },\n\n  // Sorts the models & notifies listeners that the database has been updated.\n  updated: function()\n  {\n    this.models.sort( this.comparator );\n    this.trigger( 'updated' );\n  },\n\n  // Handles when we receive data from the server - either from\n  // a publish, refresh, or values being returned on a save.\n  putRemoteData: function(encoded, key, model)\n  {\n    var db = this;\n    var key = key || encoded[ db.key ];\n    var model = model || db.models.get( key );\n    var decoded = db.decode( copy( encoded ) );\n\n    if ( model && model.$saved )\n    {\n      var current = model.$toJSON();\n\n      for (var prop in encoded)\n      {\n        var currentValue = current[ prop ];\n        var savedValue = model.$saved[ prop ];\n\n        if ( equals( currentValue, savedValue ) )\n        {\n          model[ prop ] = decoded[ prop ];\n          model.$local[ prop ] = encoded[ prop ];\n        }\n\n        model.$saved[ prop ] = copy( encoded[ prop ] );\n      }\n\n      model.$queue(function()\n      {\n        Neuro.debug( Neuro.Events.REMOTE_UPDATE, encoded, model );\n\n        return db.stork.save( model.$local );\n      });\n    }\n    else\n    {\n      model = db.instantiate( decoded );\n\n      model.$local = encoded;\n      model.$saved = model.$local.$saved = copy( encoded );\n\n      model.$queue(function()\n      {\n        Neuro.debug( Neuro.Events.REMOTE_CREATE, encoded, model );\n\n        return db.stork.save( model.$local );\n      });\n\n      db.models.put( key, model );\n    }\n\n    model.trigger('saved');\n\n    return model;\n  },\n\n  // Destroys a model locally because it doesn't exist remotely\n  destroyLocalModel: function(key)\n  {\n    var db = this;\n    var model = db.models.get( key );\n\n    if ( model )\n    {\n      if ( model.$hasChanges() )\n      {\n        // Removed saved history and the current ID\n        delete model.$saved;\n        delete model.$local.$saved;\n        delete model[ db.key ];\n        delete model.$local[ db.key ];\n\n        model.$queue(function()\n        {\n          return db.stork.save( model.$local );\n        });\n     \n        return false;\n      }\n\n      model.$queue(function()\n      {\n        return db.stork.remove( key );\n\n      }, true );\n\n      db.models.remove( key );\n\n      model.trigger('removed');\n\n      Neuro.debug( Neuro.Events.REMOTE_REMOVE, model );\n    }\n    else\n    {\n      db.stork.remove( key, function(removedValue)\n      {\n        if (removedValue) \n        {\n          Neuro.debug( Neuro.Events.REMOTE_REMOVE, removedValue );\n        }\n      });\n\n      // The model didn't exist\n      return false;\n    }\n\n    return true;\n  },\n\n  // Initialize the database by loading local values and on success load\n  // remove values.\n  init: function()\n  {\n    var db = this;\n\n    db.PROMISED = new Stork.Promise( db ).$success();\n\n    db.stork.all(function(records, keys)\n    {\n      Neuro.debug( Neuro.Events.LOCAL_LOAD, records );\n\n      db.models.reset();\n\n      for (var i = 0; i < records.length; i++) \n      {\n        var encoded = records[ i ];\n        var key = keys[ i ];\n        var decoded = db.decode( copy( encoded, true ) );\n        var inst = db.instantiate( decoded );\n\n        inst.$local = encoded;\n\n        if ( encoded.$deleted )\n        {\n          Neuro.debug( Neuro.Events.LOCAL_RESUME_DELETE, inst );\n\n          db.removeRemote( inst );\n        }\n        else\n        {\n          if ( !encoded.$saved )\n          {\n            Neuro.debug( Neuro.Events.LOCAL_RESUME_SAVE, inst );\n\n            db.saveRemote( inst );\n          }\n          else\n          {\n            Neuro.debug( Neuro.Events.LOCAL_LOAD_SAVED, inst );\n          }\n\n          db.models.put( key, inst );\n        }\n      }\n\n      db.updated();\n\n      db.loadRemote();\n    });    \n  },\n\n  // Loads all data remotely\n  loadRemote: function()\n  {\n    var db = this;\n\n    var loadPromise = new Stork.Promise( this );\n\n    var options = {\n      method: 'GET',\n      url: this.rest\n    };\n\n    Neuro.rest( options, loadPromise );\n\n    loadPromise.then(\n      function onModels(models) \n      {\n        var mapped = {};\n\n        for (var i = 0; i < models.length; i++)\n        {\n          var model = db.putRemoteData( models[ i ] );\n          var key = model.$key();\n\n          mapped[ key ] = model;\n        }\n\n        var keys = db.models.keys;\n\n        for (var i = 0; i < keys.length; i++)\n        {\n          var k = keys[ i ];\n\n          if ( !(k in mapped) )\n          {\n            var old = db.models.get( k );\n\n            if ( old.$saved )\n            {\n              Neuro.debug( Neuro.Events.REMOTE_LOAD_REMOVE, k );\n\n              db.destroyLocalModel( k );\n            }\n          }\n        }\n\n        db.updated();\n\n        Neuro.debug( Neuro.Events.REMOTE_LOAD, models );\n      },\n      function onLoadError(models, status) \n      {\n        if ( status === 0 )\n        {\n          Neuro.checkNetworkStatus();\n\n          if ( !Neuro.online )\n          {\n            db.$pendingLoad = true;\n\n            Neuro.once('online', function()\n            {\n              Neuro.debug( Neuro.Events.REMOTE_LOAD_RESUME );\n\n              if ( db.$pendingLoad )\n              {\n                db.$pendingLoad = false;\n\n                db.loadRemote(); \n              }\n            })\n          }\n\n          Neuro.debug( Neuro.Events.REMOTE_LOAD_OFFLINE );\n        }\n        else\n        {\n          Neuro.debug( Neuro.Events.REMOTE_LOAD_ERROR, status );\n        }\n      }\n    );\n  },\n\n  // The reference to all of the models in the database\n  getModels: function()\n  {\n    return this.models.values;\n  }, \n\n  // Crates a function for handling real-time changes\n  handlePublish: function(db)\n  {\n    return function(message)\n    {\n      var key = message.key;\n      var encoded = message.model;\n\n      switch (message.op) \n      {\n      case 'SAVE':\n\n        db.putRemoteData( encoded, key );\n        db.updated();\n\n        Neuro.debug( Neuro.Events.REALTIME_SAVE, message.model );\n        break;\n\n      case 'REMOVE':\n\n        if ( db.destroyLocalModel( key ) )\n        {\n          db.updated(); \n        }\n\n        Neuro.debug( Neuro.Events.REALTIME_REMOVE, key );\n        break;\n      }\n    };\n  },\n\n  // Return an instance of the model with the data as initial values\n  instantiate: function(data)\n  {\n    return new this.model( data );\n  },\n\n  // Converts properties in data into their storable form\n  encode: function(data)\n  {\n    return data;\n  },\n\n  // Converts properties in rawData from their storable form to their desired\n  decode: function(rawData)\n  {\n    return rawData;\n  },\n\n  // Waits for the given promise to finish before proceeding with the method\n  waitForPending: function(promise, method, args)\n  {\n    var db = this;\n\n    if ( promise.$pending() )\n    {\n      promise.either(function()\n      {\n        method.apply( db, args );\n      });\n\n      return true;\n    }\n    else\n    {\n      promise.$reset();\n\n      return false;\n    }\n  },\n\n  // Interrupt a pending promise\n  interruptPending: function(promise)\n  {\n    promise.$clear();\n  },\n\n  // Save a model remotely\n  saveRemote: function(model)\n  {\n    var db = this;\n    var promise = model.$promise;\n    var promiseRest = new Stork.Promise( model );\n\n    // If the model is deleted, return immediately!\n    if ( model.$deleted )\n    {\n      Neuro.debug( Neuro.Events.SAVE_REMOTE_DELETED, model );\n\n      return promise;\n    }\n\n    // Wait for other methods to finish executing\n    if ( db.waitForPending( promise, this.saveRemote, arguments ) )\n    {\n      Neuro.debug( Neuro.Events.SAVE_REMOTE_BLOCKED, model );\n\n      return promise;\n    }\n\n    var encoded = model.$toJSON();\n\n    // The fields that have changed since last save\n    var $saving = model.$saved ? \n      diff( encoded, model.$saved, db.fields, equals ) :\n      encoded;\n\n    var key = model.$key();\n\n    // Make the REST call to remove the mdoel\n    var options = {\n      method: model.$saved ? 'PUT' : 'POST',\n      url:    model.$saved ? db.rest + key : db.rest,\n      data:   $saving\n    };\n    Neuro.rest( options, promiseRest );\n\n    // FInish saving the model\n    var finishSave = function(data)\n    {\n      // Check deleted one more time before updating model.\n      if ( model.$deleted )\n      {\n        Neuro.debug( Neuro.Events.SAVE_REMOTE_DELETED, model, data );\n\n        return promise.$failure();\n      }\n\n      // If data was returned, place it in saving to update the model and publish\n      for (var prop in data)\n      {\n        if ( !(prop in $saving ) )\n        {\n          $saving[ prop ] = data[ prop ];\n        }\n      }\n\n      Neuro.debug( Neuro.Events.SAVE_VALUES, $saving, model );\n\n      // If the model hasn't been saved before - create the record where the \n      // local and model point to the same object.\n      if ( !model.$saved )\n      {\n        model.$saved = model.$local.$saved = {};\n      }\n       \n      // Update the model with the return data\n      db.putRemoteData( $saving, key, model );\n\n      // Success!\n      promise.$success();\n\n      Neuro.debug( Neuro.Events.SAVE_PUBLISH, $saving, model );\n\n      // Publish saved data to everyone else\n      db.channel.publish({\n        op: 'SAVE',\n        model: $saving,\n        key: key\n      });\n    };\n\n    promiseRest.then(\n      function onRemoteSave(data) \n      {\n        Neuro.debug( Neuro.Events.SAVE_REMOTE, model );\n\n        // Update the model with the data saved and returned\n        finishSave( data );\n      },\n      function onRemoteFailure(data, status) \n      {\n        // A non-zero status means a real problem occurred\n        if ( status === 409 ) // 409 Conflict\n        {\n          Neuro.debug( Neuro.Events.SAVE_CONFLICT, data, model );\n\n          // Update the model with the data saved and returned\n          finishSave( data );\n        }\n        else if ( status === 410 || status === 404 ) // 410 Gone, 404 Not Found\n        {\n          Neuro.debug( Neuro.Events.SAVE_UPDATE_FAIL, model );\n\n          promise.$failure();\n\n          model.$queue(function()\n          {\n            db.models.remove( key );\n\n            return db.stork.remove( key );\n          });\n        }\n        else if ( status !== 0 ) \n        {          \n          Neuro.debug( Neuro.Events.SAVE_ERROR, model, status );\n\n          promise.$failure();\n        } \n        else \n        {\n          // Check the network status right now\n          Neuro.checkNetworkStatus();\n\n          // If not online for sure, try saving once online again\n          if (!Neuro.online) \n          {\n            model.$pendingSave = true;\n\n            Neuro.once('online', function() \n            {\n              if ( model.$pendingSave )\n              { \n                model.$pendingSave = false;\n\n                Neuro.debug( Neuro.Events.SAVE_RESUME, model );\n\n                db.saveRemote( model, true );\n              }\n            });\n\n            promise.$success();\n          } \n          else \n          {\n            promise.$failure();\n          }\n\n          Neuro.debug( Neuro.Events.SAVE_OFFLINE, model );\n        }\n      }\n    );\n\n    return promise;\n  },\n\n  // Save the model locally then try remotely\n  save: function(model)\n  {\n    var db = this;\n    var promise = model.$promise;\n    var key = model.$key();\n\n    // If the model is deleted, return immediately!\n    if ( model.$deleted )\n    {\n      Neuro.debug( Neuro.Events.SAVE_DELETED, model );\n\n      return promise;\n    }\n\n    // Place the model and trigger a database update.\n    if ( !db.models.has( key ) )\n    {\n      db.models.put( key, model );\n      db.updated();\n    }\n\n    return db.saveLocal( model );\n  },\n\n  // Saves the model locally\n  saveLocal: function(model)\n  {\n    var db = this;\n    var promise = model.$promise;\n    var encoded = model.$toJSON();\n\n    // If the model is deleted, return immediately!\n    if ( model.$deleted )\n    {\n      Neuro.debug( Neuro.Events.SAVE_LOCAL_DELETED, model );\n\n      return promise;\n    }\n\n    // Wait for other methods to finish executing\n    if ( db.waitForPending( promise, this.saveLocal, arguments ) )\n    {\n      Neuro.debug( Neuro.Events.SAVE_LOCAL_BLOCKED, mdoel );\n\n      return promise;\n    }\n\n    // If this model doesn't have a local copy yet - create it.\n    if ( !model.$local ) \n    {\n      model.$local = encoded;\n    } \n    else \n    {\n      // Copy to the local copy\n      transfer( encoded, model.$local );\n    }\n\n    // Save the local copy of the model.\n    var localSave = db.stork.save( model.$local );\n\n    // Finishes the local saving\n    var finishSave = function()\n    {\n      promise.$success();\n\n      db.saveRemote( model );\n    };\n\n    localSave.then(\n      function onLocalSave(encoded) \n      {\n        Neuro.debug( Neuro.Events.SAVE_LOCAL, model );\n\n        finishSave();\n      },\n      function onLocalFailure(e) \n      {\n        Neuro.debug( Neuro.Events.SAVE_LOCAL_ERROR, model, e );\n\n        finishSave();\n      }\n    );\n\n    return promise;\n  },\n\n  // Remove remotely\n  removeRemote: function(model)\n  {\n    var db = this;\n    var promise = model.$promise;\n    var promiseRest = new Stork.Promise( model );\n    var key = model.$key();\n    \n    // Cancel any pending saves\n    model.$pendingSave = false;\n    model.$deleted = true;\n\n    // Removals cancel other operations\n    db.interruptPending( promise );\n\n    // Wait for an existing promise to finish\n    if ( db.waitForPending( promise, this.removeRemote, arguments ) )\n    {\n      Neuro.debug( Neuro.Events.REMOVE_REMOTE_BLOCKED, model );\n\n      return promise;\n    }\n\n    // Make the REST call to remove the model\n    var options = {\n      method: 'DELETE',\n      url:    this.rest + key\n    };\n    Neuro.rest( options, promiseRest );\n\n    // Finish removing the model\n    var removeModel = function()\n    {\n      Neuro.debug( Neuro.Events.REMOVE_LOCAL, key, model ); \n\n      // We're done removing when it's removed locally.\n      promise.$bindTo( db.stork.remove( key ) );\n\n      // Notify the model that it's been removed\n      model.trigger('removed');\n\n      // Publish REMOVE\n      Neuro.debug( Neuro.Events.REMOVE_PUBLISH, key, model );\n\n      db.channel.publish({\n        op: 'REMOVE',\n        key: key\n      });\n    };\n\n    promiseRest.then(\n      function onRemoteRemove(data) \n      {\n        Neuro.debug( Neuro.Events.REMOVE_REMOTE, model );\n\n        removeModel();\n      },\n      function onRemoteFailure(data, status) \n      {\n        if ( status === 404 || status === 410 )\n        {\n          Neuro.debug( Neuro.Events.REMOVE_MISSING, key, model );\n\n          removeModel();\n        }\n        else if ( status !== 0 ) \n        {\n          Neuro.debug( Neuro.Events.REMOVE_ERROR, status, key, model );\n\n          promise.$failure();\n        } \n        else \n        {\n          // Looks like we're offline!\n          Neuro.checkNetworkStatus();\n\n          // If we are offline, wait until we're online again to resume the delete\n          if (!Neuro.online) \n          {\n            Neuro.once('online', function() \n            {\n              Neuro.debug( Neuro.Events.REMOVE_RESUME, model );\n            });\n\n            promise.$success();\n          } \n          else\n          {\n            promise.$failure();\n          }\n\n          Neuro.debug( Neuro.Events.REMOVE_OFFLINE, model );\n        }\n      }\n    );\n\n    return promise;\n  },\n\n  removeLocal: function(model)\n  {\n    var db = this;\n    var promise = model.$promise;\n    var key = model.$key();\n\n    // Removals cancel other operations\n    db.interruptPending( promise );\n\n    // Wait for an existing promise to finish\n    if ( db.waitForPending( promise, this.removeLocal, arguments ) )\n    {\n      Neuro.debug( Neuro.Events.REMOVE_LOCAL_BLOCKED, model );\n\n      return promise;\n    }\n\n    // If there is no local there's nothing to remove from anywhere!\n    if ( !model.$local )\n    {\n      Neuro.debug( Neuro.Events.REMOVE_LOCAL_NONE, model );\n\n      return promise.$success();\n    }\n\n    // If this model hasn't been saved we only need to remove it from local\n    // storage.\n    if ( !model.$saved )\n    {\n      Neuro.debug( Neuro.Events.REMOVE_LOCAL_UNSAVED, model );\n\n      promise.$bindTo( db.stork.remove( key ) );\n    }\n    else\n    {\n      // Mark local copy as deleted in the event we're not online\n      model.$local.$deleted = true;\n\n      var localSave = db.stork.save( model.$local );\n\n      var localRemove = function()\n      {\n        // If the model is saved, make sure we call removeRemote immediately.\n        if ( model.$saved )\n        {\n          db.interruptPending( promise );\n\n          promise.$success();\n\n          db.removeRemote( model ); \n        }\n        else\n        {\n          promise.$success();\n        }\n      };\n\n      localSave.then(\n        function onLocalRemove(encoded) \n        {\n          Neuro.debug( Neuro.Events.REMOVE_LOCAL, model );\n\n          localRemove();          \n        },\n        function onLocalFailure(e) \n        {\n          Neuro.debug( Neuro.Events.REMOVE_LOCAL_ERROR, model, e );\n\n          localRemove();\n        }\n      );\n    }\n\n    return promise;\n  },\n\n  remove: function(model)\n  {\n    var db = this;\n    var key = model.$key();\n\n    // If we have it in the models, remove it!\n    if ( db.models.has( key ) )\n    {\n      db.models.remove( key );\n      db.updated();\n    }\n\n    // Mark as deleted right away\n    model.$deleted = true;\n\n    // If we're offline and we have a pending save - cancel the pending save.\n    // TODO Add Debug here?\n    if ( model.$pendingSave )\n    {\n      Neuro.debug( Neuro.Events.REMOVE_CANCEL_SAVE, model );\n\n      model.$pendingSave = false; \n    }\n\n    // Remove it locally\n    return db.removeLocal( model );\n  }\n\n};\n\neventize( NeuroDatabase.prototype );","\nfunction NeuroModel(db)\n{\n  this.$db = db;\n  this.$promise = Stork.Promise.Done( this );\n  this.$pendingSave = false;\n  this.$pendingRemove = false;\n\n  /**\n   * @property {NeuroDatabase} $db\n   *           The reference to the database this model is stored in.\n   */\n\n  /**\n   * @property {Stork.Promise} $promise\n   *           The last promise on the model. When this promise completes \n   *           another action can be performed on the model.\n   */\n\n  /**\n   * @property {Object} [$saved]\n   *           An object of encoded data representing the values saved remotely.\n   *           If this object does not exist - the model hasn't been created\n   *           yet.\n   */\n  \n  /**\n   * @property {Boolean} [$deleted]\n   *           A flag placed on a model once it's requested to be deleted. A  \n   *           model with this flag isn't present on any arrays - it's stored\n   *           locally until its successfully removed remotely - then it's \n   *           removed locally.\n   */\n  \n  /**\n   * @property {Object} [$local]\n   *           The object of encoded data that is stored locally. It's $saved\n   *           property is the same object as this $saved property.\n   */\n  \n  /**\n   * @property {Boolean} $pendingSave\n   *           Whether there is a pending save for this model.\n   */\n}\n\nNeuroModel.prototype =\n{\n\n  $set: function(props, value)\n  {\n    if ( isObject( props ) )\n    {\n      transfer( props, this );\n    }\n    else if ( isString( props ) && value !== void 0 )\n    {\n      this[ props ] = value;\n    }\n  },\n\n  $get: function(props, copyValues)\n  {\n    if ( isArray( props ) )\n    {\n      return grab( this, props, copyValues );\n    }\n    else if ( isObject( props ) )\n    {\n      for (var p in props)\n      {\n        props[ p ] = copyValues ? copy( this[ p ] ) : this[ p ];\n      }\n\n      return props;\n    }\n    else if ( isString( props ) )\n    {\n      return copyValues ? copy( this[ props ] ) : this[ props ];\n    }\n  },\n\n  $save: function(setProperties, setValue)\n  {\n    this.$set( setProperties, setValue );\n\n    return this.$db.save( this );\n  },\n\n  $remove: function()\n  {\n    return this.$db.remove( this );\n  },\n\n  $queue: function(callback, interrupt)\n  {\n    var p = this.$promise;\n\n    if (interrupt)\n    {\n      p.$clear();\n    }\n\n    p.either(function()\n    {\n      p.$reset();\n      p.$bindTo( callback() );\n    });\n\n    return p;\n  },\n\n  $reset: function(props)\n  {\n    var def = this.$db.defaults;\n\n    for (var prop in def)\n    {\n      this[ def ] = copy( def[ prop ] );\n    }\n\n    this.$set( props );\n  },\n\n  $toJSON: function()\n  {\n    return this.$db.encode( grab( this, this.$db.fields, true ) );\n  },\n\n  $key: function()\n  {\n    var k = this.$db.key;\n\n    return k in this ? this[ k ] : (this[ k ] = this.$db.generateKey());\n  },\n\n  $isSaved: function()\n  {\n    return !!this.$saved;\n  },\n\n  $isSavedLocally: function()\n  {\n    return !!this.$local;\n  },\n\n  $hasChanges: function()\n  {\n    if (!this.$saved) \n    {\n      return true;\n    }\n\n    var encoded = this.$toJSON();\n    var saved = this.$saved;\n\n    for (var prop in encoded) \n    {\n      var currentValue = encoded[ prop ];\n      var savedValue = saved[ prop ];\n\n      if ( !equals( currentValue, savedValue ) ) \n      {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n};\n\neventize( NeuroModel.prototype );","\nNeuro.debug = function(event, data)\n{\n  // up to the user\n};\n\nNeuro.Events = {\n\n  CREATION: 0,                // options, NeuroDatabase\n\n  REST: 1,                    // options\n\n  REMOTE_UPDATE: 2,           // encoded, NeuroModel\n  REMOTE_CREATE: 3,           // encoded, NeuroModel\n  REMOTE_REMOVE: 4,           // NeuroModel\n  REMOTE_LOAD: 5,             // encoded[]\n  REMOTE_LOAD_OFFLINE: 6,     // \n  REMOTE_LOAD_ERROR: 7,       // status\n  REMOTE_LOAD_REMOVE: 8,      // key\n  REMOTE_LOAD_RESUME: 22,     // \n\n  LOCAL_LOAD: 9,              // encoded[]\n  LOCAL_RESUME_DELETE: 10,    // NeuroModel\n  LOCAL_RESUME_SAVE: 11,      // NeuroModel\n  LOCAL_LOAD_SAVED: 12,       // NeuroModel\n\n  REALTIME_SAVE: 13,          // encoded\n  REALTIME_REMOVE: 14,        // key\n\n  SAVE_VALUES: 15,            // encoded, NeuroModel\n  SAVE_PUBLISH: 16,           // encoded, NeuroModel\n  SAVE_CONFLICT: 17,          // encoded, NeuroModel\n  SAVE_UPDATE_FAIL: 18,       // NeuroModel\n  SAVE_ERROR: 19,             // NeuroModel, status\n  SAVE_OFFLINE: 20,           // NeuroModel\n  SAVE_RESUME: 21,            // NeuroModel\n  SAVE_REMOTE: 25,            // NeuroModel\n  SAVE_DELETED: 40,           // NeuroModel\n\n  SAVE_LOCAL: 23,             // NeuroModel\n  SAVE_LOCAL_ERROR: 24,       // NeuroModel, error\n  SAVE_LOCAL_DELETED: 38,     // NeuroModel\n  SAVE_LOCAL_BLOCKED: 39,     // NeuroModel\n\n  SAVE_REMOTE_DELETED: 41,    // NeuroModel, [encoded]\n  SAVE_REMOTE_BLOCKED: 42,    // NeuroModel\n\n  REMOVE_PUBLISH: 26,         // key, NeuroModel\n  REMOVE_LOCAL: 27,           // key, NeuroModel\n  REMOVE_MISSING: 28,         // key, NeuroModel\n  REMOVE_ERROR: 29,           // status, key, NeuroModel\n  REMOVE_OFFLINE: 30,         // NeuroModel\n  REMOVE_RESUME: 31,          // NeuroModel\n  REMOVE_REMOTE: 32,          // NeuroModel\n  REMOVE_CANCEL_SAVE: 47,     // NeuroModel\n\n  REMOVE_LOCAL: 33,           // NeuroModel\n  REMOVE_LOCAL_ERROR: 34,     // NeuroModel, error\n  REMOVE_LOCAL_BLOCKED: 44,   // NeuroModel\n  REMOVE_LOCAL_NONE: 45,      // NeuroModel\n  REMOVE_LOCAL_UNSAVED: 46,   // NeuroModel\n\n  REMOVE_REMOTE_BLOCKED: 43,  // NeuroModel\n\n  ONLINE: 35,                 //\n  OFFLINE: 36,                //\n\n  PUBSUB_CREATED: 37          // PubSub\n\n};","\n// Neuro.rest = function(options, success(data), failure(data, status))\n\nNeuro.rest = function(options, promise)\n{\n  // success ( data )\n  // failure ( data, status )\n  promise.$failure( [{}, 0] );\n};","\nNeuro.getPubSub = function(url)\n{\n  if ( !(url in Neuro.pubsubs) )\n  {\n    var pubsub = new PubSub( url );\n\n    Neuro.pubsubs[ url ] = pubsub;\n\n    Neuro.debug( Neuro.Events.PUBSUB_CREATED, pubsub );\n  }\n\n  return Neuro.pubsubs[ url ];\n};\n\nNeuro.pubsubs = {};","\n// Initial online\nNeuro.online = window.navigator.onLine !== false;\n\nNeuro.forceOffline = false;\n\n// Set network status to online and notify all listeners\nNeuro.setOnline = function()\n{\n  Neuro.online = true;\n  Neuro.debug( Neuro.Events.ONLINE );\n  Neuro.trigger('online');\n};\n\n// Set network status to offline and notify all listeners\nNeuro.setOffline = function()\n{\n  Neuro.online = false;\n  Neuro.debug( Neuro.Events.OFFLINE );\n  Neuro.trigger('offline');\n};\n\n// This must be called manually - this will try to use built in support for \n// online/offline detection instead of solely using status codes of 0.\nNeuro.listenToNetworkStatus = function()\n{\n  if (window.addEventListener) \n  {\n    window.addEventListener( 'online', Neuro.setOnline, false );\n    window.addEventListener( 'offline', Neuro.setOffline, false );\n  } \n  else \n  {\n    document.body.ononline = Neuro.setOnline;\n    document.body.onoffline = Neuro.setOffline;\n  }\n};\n\n// Check to see if the network status has changed.\nNeuro.checkNetworkStatus = function()\n{\n  var online = window.navigator.onLine;\n\n  if ( Neuro.forceOffline ) \n  {\n    online = false;\n  }\n\n  if (online === true && Neuro.online === false) \n  {\n    Neuro.setOnline();\n  }\n\n  else if (online === false && Neuro.online === true) \n  {\n    Neuro.setOffline();\n  }\n};","\n  global.Neuro = Neuro;\n\n})(window);"],"sourceRoot":"/source/"}